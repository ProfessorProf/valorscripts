<script type="text/worker">

    /**
     * VALOR CHARACTER SHEET v1.9.0
     *
     * Installation Instructions:
     * - Be a Roll20 Pro user.
     * - From your game's main screen, go to Game Settings.
     * - Under Character Sheet Template, select Custom.
     * - Copy the contents of valor.html into the HTML Layout tab.
     * - Copy the contents of valor.css into the CSS Styling tab.
     *
     * Usage:
     * - For Boosts, Weakens, or other techniques that grant skills or flaws, list
     * them in the Description field.
     * - If you want to use unlisted mods or limits, enter "Custom #", where # is
     * the number of tech levels to add or how much to reduce ST by.
     * - If you want to use unlisted skills or flaws, choose 'Custom Skill' or
     * 'Custom Flaw' and set the level to the amount of SP.
     *
     **/

    let flawLibrary = [
        { cost: 1,  levelUp: 1, speed: 3, id: 'customFlaw', namePattern: '^custom' },
        { cost: 2,  levelUp: 0, speed: 0, id: 'aggravatedWounds', namePattern: '^aggravated', description: 'Incoming healing is halved.' },
        { cost: 5,  levelUp: 0, speed: 0, id: 'berserker', namePattern: '^berserk', description: 'When critical, get +10 attack, -10 defense/resistance, +1 to attack rolls, and -2 to defense rolls.' },
        { cost: 4,  levelUp: 0, speed: 0, id: 'compulsion', namePattern: '^compulsion', description: 'Every even-numbered round, waste a support action or lose 1 Valor.' },
        { cost: 4,  levelUp: 0, speed: 0, id: 'despair', namePattern: '^despair', description: 'The first time an ally falls in a scene, -2 Valor.' },
        { cost: 2,  levelUp: 1, speed: 2, id: 'energyVulnerability', namePattern: '^energy vuln', description: 'Resistance is reduced.' },
        { cost: 3,  levelUp: 0, speed: 0, id: 'feeble', namePattern: '^feeble', description: '-1 to defense rolls against Muscle techniques.' },
        { cost: 3,  levelUp: 2, speed: 2, id: 'fragile', namePattern: '^fragile', description: 'Max Health is reduced.' },
        { cost: 2,  levelUp: 1, speed: 2, id: 'lackOfControl', namePattern: '^lack ', description: 'Max Stamina is reduced.' },
        { cost: 5,  levelUp: 0, speed: 0, id: 'malevolentEntity', namePattern: '^malevolent entity', description: 'When damage leaves you critical, roll to resist being taken over by the Malevolent Entity.' },
        { cost: 1,  levelUp: 0, speed: 0, id: 'nonProficient', namePattern: '^non[ -]?proficient', description: '-1 to rolls made for a specific Challenge action.' },
        { cost: 3,  levelUp: 0, speed: 0, id: 'oblivious', namePattern: '^oblivious', description: '-1 to defense rolls against Intuition techniques.' },
        { cost: 2,  levelUp: 1, speed: 1, id: 'slow', namePattern: '^slow$', description: 'Move is reduced.' },
        { cost: 2,  levelUp: 0, speed: 0, id: 'slowHealing', namePattern: '^slow heal', description: "Don't recover health in the first scene after a fight." },
        { cost: 1,  levelUp: 0, speed: 0, id: 'slowToAct', namePattern: '^slow to act', description: 'Initiative rolls are reduced.' },
        { cost: 3,  levelUp: 0, speed: 0, id: 'unthreatening', namePattern: '^unthreatening', description: "Enemies aren't slowed in your Zone of Control." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'uncoordinated', namePattern: '^uncoordinated', description: '-1 to defense rolls against Dexterity techniques.' },
        { cost: 3,  levelUp: 0, speed: 0, id: 'violent', namePattern: '^violent', description: "If you choose not to attack anyone on a turn, -2 Valor." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'weakAura', namePattern: '^weak aura', description: "-1 to defense rolls against Aura attacks." },
        { cost: 2,  levelUp: 1, speed: 2, id: 'weakDefender', namePattern: '^weak defend', description: "Defense is reduced." },
        { cost: 4,  levelUp: 3, speed: 1, id: 'weakWilled', namePattern: '^weak will', description: "-1 Valor at the start of a scene." },
        { cost: 1,  levelUp: 0, speed: 0, id: 'unprincipled', namePattern: '^unprincipled', description: "Gain an extra Vice." },
        { cost: 2,  levelUp: 1, speed: 1, id: 'elementalVulnerability', namePattern: '^elemental vuln', description: "Take extra damage from one element." },
        { cost: 2,  levelUp: 1, speed: 1, id: 'armorReliant', namePattern: '^armor reliant', description: "Defense reduced when not wearing armor." },
        { cost: 2,  levelUp: 1, speed: 1, id: 'wardReliant', namePattern: '^ward reliant', description: "Resistance reduced when not using a ward." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'broadForm', namePattern: '^broad form', description: "Smaller characters can stand on top of you." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'fearTheDarkness', namePattern: '^fear the dark', description: "When someone in your party succumbs to the Malevolent Entity, -2 Valor." },
        { cost: 7,  levelUp: 0, speed: 0, id: 'immobile', namePattern: '^immobile', description: "Cannot move." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'insubstantial', namePattern: '^insubstantial', description: "Characters can occupy your space." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'situationalCompulsion', namePattern: '^situational compulsion', description: "When a specific condition occurs, you must waste a Support Action or lose 1 Valor." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'sunlightWeakness', namePattern: '^sunlight', description: "While standing in sunlight, you lose a Health Increment and 1 Valor each turn." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'thresheld', namePattern: '^thresheld', description: "You cannot enter a home or haven without explicit permission." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'weakGuard', namePattern: '^weak guard', description: "Critical threshold is reduced by 2." },
        { cost: 10, levelUp: 0, speed: 0, id: 'malevolentPossession', namePattern: '^malevolent possess', description: "Malevolent Entity has been applied to you by an outside force." },
        { cost: 3,  levelUp: 2, speed: 2, id: 'weakPhysicalAttacker', namePattern: '^weak phys(ical)? attack', description: "Physical Attack is reduced." },
        { cost: 3,  levelUp: 2, speed: 2, id: 'weakEnergyAttacker', namePattern: '^weak en(ergy)? attack', description: "Energy Attack is reduced." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'impairedAccuracy', namePattern: '^impaired acc', description: "-1 to attack rolls." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'impairedEvasion', namePattern: '^impaired (evd|eva)', description: "-1 to defense rolls." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'flightless', namePattern: '^flightless', description: "Cannot fly." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'battleDamage', namePattern: '^battle damage', description: "If you take a Health Increment of damage, -1 to all rolls for the rest of the scene." }
    ];
    let skillLibrary = [
        { cost: 1,  levelUp: 1, speed: 3, id: 'customSkill', namePattern: '^custom' },
        { cost: 8,  levelUp: 0, speed: 0, id: 'balancedFighter', namePattern: '^balanced', description: "+1 to all active attributes below your highest attribute." },
        { cost: 6,  levelUp: 6, speed: 0, id: 'bravado', namePattern: '^bravado', description: "+1 Valor at the start of a scene." },
        { cost: 3,  levelUp: 0, speed: 0, rollStats: ['aur'], id: 'discreetAura', namePattern: '^discreet', description: "Can roll Aura to resist Spirit Sight." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'darksight', namePattern: '^dark( )?sight', description: "No penalties from fighting in darkness." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'energyAttacker', namePattern: '^en(ergy)? attack', description: "Energy Attack is increased." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'fastHealing', namePattern: '^fast heal', description: "Heal more between scenes." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'improvedDamageIncrement', namePattern: '^improved damage inc', description: "Damage Increment increased." }, // ERRATA: Reduced cost for IDI
        { cost: 2,  levelUp: 1, speed: 2, id: 'increasedSize', namePattern: '^increased size', description: "Take up more space, +1 to attack rolls, -1 to defense rolls, +2 to critical threshold." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'ironDefense', namePattern: '^iron def', description: "Defense is increased." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'physicalAttacker', namePattern: '^phys(ical)? attack', description: "Physical Attack is increased." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'resistant', namePattern: '^resistan', description: "Resistance is increased." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'sprinter', namePattern: '^sprint', description: "Move is increased." },
        { cost: 5,  levelUp: 2, speed: 2, id: 'tireless', namePattern: '^tireless', description: "Max Stamina is increased." },
        { cost: 6,  levelUp: 3, speed: 2, id: 'tough', namePattern: '^tough$', description: "Max Health is increased." },
        { cost: 6,  levelUp: 3, speed: 2, id: 'versatileFighter', namePattern: '^versatile', description: "Technique Points are increased." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'skyAttack', namePattern: '^sky attack', description: "Bonus damage against flying targets." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'breakValorLimit', namePattern: '^break valor', description: "Max Valor is increased." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'expandedReach', namePattern: '^expanded reach', description: "Zone of Control is one space wider." },
        { cost: 12, levelUp: 0, speed: 0, id: 'extraAction', namePattern: '^extra action', description: "Gain an extra Support Action each turn." },
        { cost: 6,  levelUp: 4, speed: 1, id: 'regeneration', namePattern: '^regen', description: "Recover health each turn." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'staminaRecovery', namePattern: '^stamina recover', description: "Recover stamina each turn." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'teleportation', namePattern: '^teleport', description: "Ignore all obstacles when moving." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'unyieldingDetermination', namePattern: '^unyielding', description: "+1 Valor when gaining valor from dramatic speech or action." }, // ERRATA: Reduced cost, different effect
        { cost: 4,  levelUp: 0, speed: 0, id: 'violentAura', namePattern: '^violent aura', description: "While active, damage all enemies in your Zone of Control at start of turn." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'bounceBack', namePattern: '^bounce back', description: "If Valor is below 0, gain 1 extra Valor each round." },
        { cost: 4,  levelUp: 2, speed: 2, id: 'crisis', namePattern: '^crisis$', description: "Attack is increased while critical." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'dangerSense', namePattern: '^danger sense', description: "Can't be Surprised." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'desperation', namePattern: '^desperation', description: "+1 to defense rolls while Critical." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'digDeep', namePattern: '^dig deep', description: "Can pay for techniques using Health instead of Stamina." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'discretion', namePattern: '^discretion', description: "Can choose to reduce any of your rolls by 3." },
        { cost: 6,  levelUp: 3, speed: 2, id: 'empowerAttack', namePattern: '^empower', description: "Can use a Slow Action when attacking to do extra damage." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'improvedSwimming', namePattern: '^improved swim', description: "No penalties to rolls while swimming." },
        { cost: 4,  levelUp: 0, speed: 0, rollStats: ['dex'], id: 'nimbleMovement', namePattern: '^nimble move', description: "On success, move through the target's Zone of Control without being slowed this turn." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'overloadLimits', namePattern: '^overload limit', description: "Can ignore limits by paying full Stamina cost." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'passiveHealing', namePattern: '^passive heal', description: "Can forego a Stamina Increment when recovering to heal someone else by a Health Increment." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'protector', namePattern: '^protector', description: "When you Cover a specific character, +1 Valor." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'quickToAct', namePattern: '^quick to act', description: "+3 to Initiative rolls." },
        { cost: 5,  levelUp: 3, speed: 1, id: 'recklessAttack', namePattern: '^reckless', description: "Can increase attack rolls, but take a penalty to defense rolls." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'resoluteStrike', namePattern: '^resolute strike', description: "If Valor is at least 2, can roll with Resolve when attacking." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'revenge', namePattern: '^revenge', description: "The first time an ally falls in a scene, +2 Valor." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'rollingRecovery', namePattern: '^rolling recover', description: "If you stand from prone with a Move Action, you can move at half speed." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'teamTactics', namePattern: '^team tactic', description: "+1 to attack rolls if you and an ally are adjacent to the target, but not each other." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'unmovable', namePattern: '^unmovable', description: "Reduces distance of repositions." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'abundantCreation', namePattern: '^abundant creat', description: "Can create an extra Attack Node, Portal, or Refraction Point with each action." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'cloneTactics', namePattern: '^clone tactic', description: "+1 to attack rolls if you and a clone are both within range of the target." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'combatToss', namePattern: '^combat toss', description: "If you Toss someone, they get +1 to their next attack roll." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'daredevil', namePattern: '^daredevil', description: "When critical, +1 valor each time you successfully defend against an attack." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'phasing', namePattern: '^phasing', description: "Can spend 2 Stamina to pass through walls." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'risingAttack', namePattern: '^rising attack', description: "When standing from prone, +1 to your next attack roll." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'safeStride', namePattern: '^safe stride', description: "Ignore damaging terrain." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'splitMove', namePattern: '^split move', description: "Can split your movement between two Move Actions." },
        { cost: 4,  levelUp: 0, speed: 0, rollStats: ['aur', 'int'], id: 'transposition', namePattern: '^transposition', description: "Can swap positions with someone when using Swift Step." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'underhanded', namePattern: '^underhanded', description: "No penalties up to -5 Valor." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'wallWalk', namePattern: '^wall walk', description: "Count as flying when adjacent to a wall." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'waterAdaptation', namePattern: '^water adaptation', description: "Do not lose valor while in water." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'waterWalk', namePattern: '^water walk', description: "Treat water as solid ground." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'xRayVision', namePattern: '^x[ -]?ray', description: "Target enemies through walls without penalty." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'unshakeable', namePattern: '^unshakeable', description: "Immune to Shaken." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'unstoppable', namePattern: '^unstoppable', description: "If Valor is at least 2, keep fighting up to one Health Increment below 0." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'extendedRange', namePattern: '^extended range', description: "All skills with a range of 5 have a range of 20." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'freeFlight', namePattern: '^free flight', description: "Fly costs no Stamina." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'freeSwiftStep', namePattern: '^free swift step', description: "Swift Step costs no Stamina." },
        { cost: 5,  levelUp: 2, speed: 2, id: 'attackNode', namePattern: '^attack node$', description: "Create an Attack Node within range 5 from which you can target your techniques." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'darkHealing', namePattern: '^dark heal', description: "Recover a Health Increment, but risk succumbing to the Malevolent Entity." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'dirtyTrick', namePattern: '^dirty trick', description: "Make a target Surprised, but lose 2 Valor." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'duel', namePattern: '^duel', description: "Challenge someone to a duel. On success, both gain 2 Valor, and anyone who interferes loses 4 Valor." },
        { cost: 4,  levelUp: 3, speed: 1, rollStats: ['int'], id: 'effectTransfer', namePattern: '^effect transfer', description: "Move an Attack Node, Portal, Refraction Node, or Persistent Effect." },
        { cost: 6,  levelUp: 0, speed: 0, rollStats: ['dex', 'int'], id: 'feint', namePattern: '^feint', description: "On success, next attack against target deals increased damage." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'inspire', namePattern: '^inspire', description: "Grant 1 Valor to a target who doesn't have more Valor than you." }, // ERRATA: Fixed level on Inspire
        { cost: 5,  levelUp: 3, speed: 1, rollStats: ['aur', 'res'], id: 'intimidate', namePattern: '^intimidate', description: "On success, target is Shaken." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'jump', namePattern: '^jump', description: "Become Flying for the rest of the turn." },
        { cost: 5,  levelUp: 3, speed: 1, rollStats: ['int', 'aur', 'res'], id: 'nullify', namePattern: '^nullify', description: "On success, remove a Boost, Weaken, Barrier, Attack Node, Refraction Point, Portal, or Seal created by the target." },
        { cost: 4,  levelUp: 2, speed: 2, rollStats: ['res'], id: 'provoke', namePattern: '^provoke', description: "On success, target must attack you next turn or lose 1 Valor." },
        { cost: 5,  levelUp: 3, speed: 1, id: 'recharge', namePattern: '^recharge', description: "Restore the duration of a boost or Persistent technique." },
        { cost: 3,  levelUp: 1, speed: 2, rollStats: ['int'], id: 'sizeUp', namePattern: '^size up', description: "On success, learn the Health, Stamina, Active Attributes, and Flaws of the target." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'spiritSight', namePattern: '^spirit sight', description: "While active, you can see invisible and concealed targets, and can always tell clones from the original." },
        { cost: 5,  levelUp: 2, speed: 1, id: 'toss', namePattern: '^toss', description: "Move an ally in your Zone of Control up to 4 spaces." },
        { cost: 6,  levelUp: 0, speed: 0, rollStats: ['int'], id: 'battleAnalysis', namePattern: '^battle analysis', description: "On success, may choose once later to gain +5 to a defense roll against the target's attacks." },
        { cost: 6,  levelUp: 0, speed: 1, id: 'clone', namePattern: '^clone$', description: "Create a clone, who can use techniques in your place. If it's attacked, the clone is destroyed." },
        { cost: 4,  levelUp: 0, speed: 0, rollStats: ['int', 'aur'], id: 'effectCapture', namePattern: '^effect capture', description: "On success, take control of a Boost, Weaken, Attack Node, Portal, Refraction Point, or Persistent effect." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'healthTransference', namePattern: '^health transfer', description: "Lose a Health Increment; target ally within 5 spaces gains a Health Increment." },
        { cost: 6,  levelUp: 3, speed: 2, id: 'portal', namePattern: '^portal$', description: "Create a portal within 5 spaces; all spaces containing portals are adjacent." },
        { cost: 4,  levelUp: 2, speed: 2, id: 'refractionPoint', namePattern: '^refraction point', description: "Create a Refraction Point within 5 spaces; if a technique hits it, you can target the technique again originating from that point." },
        { cost: 6,  levelUp: 3, speed: 1, rollStats: ['mus', 'dex', 'int', 'aur', 'res'], id: 'seal', namePattern: '^seal$', description: "On success, disable an enemy's Techniques or Active Skills for 3 rounds." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'shadowMeld', namePattern: '^shadow( )?meld', description: "You can hide in plain sight while in darkness." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'staminaTransference', namePattern: '^stamina transfer', description: "Lose a Stamina increment; target ally within 5 spaces gains a Stamina Increment." },
        { cost: 5,  levelUp: 2, speed: 1, id: 'swiftStep', namePattern: '^swift step', description: "Move as a Support Action, or extend the distance of a Move." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'attackNodeNetwork', namePattern: '^attack node network', description: "+1 to attack rolls if you and an attack node are both in range of the target." },
        { cost: 6,  levelUp: 0, speed: 0, rollStats: ['int'], id: 'exploitWeakness', namePattern: '^exploit weakness', description: "On success, may choose once later to gain +5 to an attack roll against the target." },
        { cost: 5,  levelUp: 0, speed: 0, rollStats: ['int', 'aur', 'res'], id: 'flunkyDomination', namePattern: '^flunky domination', description: "On success, dictate an Attack Action for a flunky within 5 spaces to take." },
        { cost: 6,  levelUp: 2, speed: 1, id: 'fly', namePattern: '^fly$', description: "Take flight, increasing Move and making you immune to melee attacks from non-flying enemies." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'refractionChain', namePattern: '^refraction chain', description: "When attacking through a refraction point, deal increased damage." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'swiftJump', namePattern: '^swift jump', description: "Jump is a Free Action." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'combinationAttack', namePattern: '^comb(o|ination) attack', description: "Once per scene, attack together with an ally, both gaining +2 to attack rolls on anything you both target." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'counterattack', namePattern: '^counter( )?attack', description: "Store an attack, then use it as a reaction when attacked." },
        { cost: 6,  levelUp: 2, speed: 2, id: 'cover', namePattern: '^cover$', description: "Take damage in place of an adjacent ally." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'ignoreEffect', namePattern: '^ignore effect', description: "While Valor is at least 2, you can use Resolve against all Active Skills." },
        { cost: 3,  levelUp: 2, speed: 1, id: 'interruptAttack', namePattern: '^interrupt attack', description: "When an enemy leaves your Zone of Control, you can use a stored attack as a reaction, reducing their Move." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'afterimage', namePattern: '^after( )?image', description: "When you Swift Step, you can leave a Clone behind, or stand still and create a Clone where you would have moved." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'areaShield', namePattern: '^area shield', description: "When defending with Aura against a Line or Blast attack, you can defend in place of allies within your Zone of Control." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'clash', namePattern: '^clash$', description: "When attacked, use a stored attack as a reaction against the attacker; whichever attack roll is higher hits, and the other is negated." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'damageFeedback', namePattern: '^damage feedback', description: "When defending against melee attacks with Muscle, deal damage to the attacker." },
        { cost: 5,  levelUp: 2, speed: 1, id: 'divingEscape', namePattern: '^diving escape', description: "When defending against Line or Blast attacks with Dexterity, move towards a safe space." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'finalAttack', namePattern: '^final attack', description: "When incapcitated, use one last Damage technique, ignoring all limits." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'lineDeflect', namePattern: '^line deflect', description: "When defending against a Line attack, you can change the direction of the line." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'mobileCover', namePattern: '^mobile cover', description: "Store a move, then use it to move adjacent to an ally and Cover them." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'mobileDodge', namePattern: '^mobile dodge', description: "When defending against an attack with Dexterity, move 1 space." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'opportunisticDodge', namePattern: '^opportunistic dodge', description: "When defending against an attack with Intuition, gain +1 to your next attack against the attacker." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'pushAway', namePattern: '^push away', description: "When defending against a melee attack with Resolve, push the target away." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'rangedInterrupt', namePattern: '^ranged interrupt', description: "Can use Interrupt Attack at any range, as long as your technique can reach the target." },
        { cost: 6,  levelUp: 0, speed: 0, rollStats: ['res'], id: 'shrugOff', namePattern: '^shrug off', description: "When at 2 or more Health, if an attack would incapacitate you, roll Resolve against attacker; on a success, you endure at 1 Health." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'defensiveClash', namePattern: '^defensive clash', description: "Can use Clash in combination with Cover." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'deflectingShield', namePattern: '^deflecting shield', description: "Can use Line Deflect in combination with Area Shield." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'prepared', namePattern: '^prepared', description: "At the start of the scene, store a technique." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'acceleration', namePattern: '^acceleration', description: "Overdrive for +1 Dexterity for the rest of the scene." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'analysis', namePattern: '^analysis', description: "Overdrive for +1 Intuition for the rest of the scene." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'blazingMight', namePattern: '^blazing might', description: "Overdrive for increased Energy Attack for the rest of the scene." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'burningPassion', namePattern: '^burning passion', description: "Overdrive for +1 Resolve for the rest of the scene." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'fightingSpirit', namePattern: '^fighting spirit', description: "Overdrive for increased Physical Attack for the rest of the scene." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'hardenedDefense', namePattern: '^hardened def', description: "Overdrive for increased Defense for the rest of the scene." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'hardenedResistance', namePattern: '^hardened res', description: "Overdrive for increased Resolve for the rest of the scene." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'resoluteAura', namePattern: '^resolute aura', description: "Overdrive for +1 Aura for the rest of the scene." },
        { cost: 5,  levelUp: 0, speed: 0, id: 'strengthOfWill', namePattern: '^strength of will', description: "Overdrive for +1 Muscle for the rest of the scene." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'asset', namePattern: '^asset', description: "Once per Challenge Scene, use an asset to gain +3 to a roll." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'challengeTechnique', namePattern: '^challenge tech', description: "Once per Challenge Scene, use a challenge technique to gain +3 to a roll." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'favorableInsight', namePattern: '^favo(u)?rable insight', description: "Can make an opposed roll to gain insight into the structure of a Challenge Scene." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'proficiency', namePattern: '^proficiency', description: "+1 to rolls when using a specific Challenge Action." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'recovery', namePattern: '^recovery', description: "When you fail with a specific Challenge Action and it would move a meter, you can spend 1 Valor to prevent it." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'favorableSuccess', namePattern: '^favorable success', description: "When you move a meter by 2 or more points, you can move another meter by 1 point." },
        { cost: 6,  levelUp: 4, speed: 1, id: 'companion', namePattern: '^companion$', description: "You have a Companion who can use techniques in your place. If it takes damage, it's temporarily disabled." },
        { cost: 2,  levelUp: 1, speed: 2, id: 'fastCompanion', namePattern: '^fast companion', description: "All your Companions have increased Move." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'hiddenCompanion', namePattern: '^hidden companion', description: "Your Companion can become invisible." },
        { cost: 3,  levelUp: 1, speed: 1, id: 'mount', namePattern: '^mount$', description: "Mount your Companion, letting you use its Movement speed as your own." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'senseMalice', namePattern: '^sense malice', description: "Your Companion can sense hostile intent." },
        { cost: 3,  levelUp: 1, speed: 1, id: 'allyMount', namePattern: '^ally mount', description: "Your allies can Mount your Companion." },
        { cost: 4,  levelUp: 4, speed: 1, id: 'companionZoneOfControl', namePattern: '^companion z', description: "Your Companion extends your Zone of Control around it." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'extendedRevival', namePattern: '^extended reviv', description: "You can revive multiple Companions with one action." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'flankAttack', namePattern: '^flank', description: "+1 to attack rolls if you and your Companion are both adjacent to an enemy." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'protectAlly', namePattern: '^protect ally', description: "Sacrifice your Companion to protect an ally from an attack." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'protectMaster', namePattern: '^protect master', description: "Sacrifice your Companion to protect yourself from an attack." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'rangedRevival', namePattern: '^ranged reviv', description: "You can revive a Companion from up to 5 spaces away." },
        { cost: 3,  levelUp: 1, speed: 1, id: 'tossingCompanion', namePattern: '^tossing companion', description: "You can use Toss through your Companion." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'trustingCompanion', namePattern: '^trusting companion', description: "Your allies can revive your Companion." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'companionSense', namePattern: '^companion sense', description: "You can use Spirit Sense through your Companion, without having the Skill." },
        { cost: 3,  levelUp: 3, speed: 1, id: 'flyingCompanion', namePattern: '^flying companion', description: "Your Companion can fly." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'instantMount', namePattern: '^instant mount', description: "Mounting your Companion is a Free Action." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'reactiveCompanion', namePattern: '^reactive companion', description: "Your Companion can use Reaction Skills." },
        { cost: 12, levelUp: 0, speed: 0, id: 'limitlessPower', namePattern: '^valiant', description: "Gain an extra Valor every round." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'invisibility', namePattern: '^invisibility', description: "Become invisible, requiring an opposed Intuition or Aura roll to detect." },
        { cost: 8,  levelUp: 3, speed: 1, id: 'revive', namePattern: '^revive$', description: "Revive up to four Flunkies or one Soldier within 5 spaces." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'principled', namePattern: '^principled', description: "Gain an extra Pillar." },
        { cost: 6,  levelUp: 3, speed: 2, id: 'illusoryAssailant', namePattern: '^illusory assailant', description: "Create illusory attackers who disappear when hit by an attac. As a Support Action, you can make one attack, but the attack inflicts Shaken instead of dealing damage." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'illusoryDisguise', namePattern: '^illusory disguise', description: "Change your appearance to something else of your size and shape." },
        { cost: 4,  levelUp: 2, speed: 2, id: 'illusoryTerrain', namePattern: '^illusory terrain', description: "Target spaces become impassable or rough terrain, which only affects those caught in the illusion." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'pierceIllusion', namePattern: '^pierce illusion', description: "You can roll to resist an illusion even while unaware of it." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'elementalResistance', namePattern: '^elemental resist', description: "Take less damage when hit by a certain element of damage." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'elementalAttunement', namePattern: '^elemental attune', description: "All your damage is of a certain element." },
        { cost: 4,  levelUp: 2, speed: 0, id: 'aquatic', namePattern: '^aquatic$', description: "Suffer no penalties underwater, but lose 2 Valor per turn when out of water." },
        { cost: 4,  levelUp: 2, speed: 0, id: 'construct', namePattern: '^construct$', description: "Critical threshold increased by 2. Take reduced damage from Damage Increments. Defense increased, Resistance reduced." },
        { cost: 4,  levelUp: 2, speed: 0, id: 'elemental', namePattern: '^elemental$', description: "Pick an element; all your damage is attuned to that element, you resist that element, and you gain 1 Valor whenever you take damage of that element. Pick another element to be vulnerable to." },
        { cost: 4,  levelUp: 2, speed: 0, id: 'undead', namePattern: '^undead$', description: "Critical threshold increased by 2. Mind techniques against you get -1 to attack roll. When between 0 and one negative Health Increment, you can still take one Attack Action each turn." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'diminuitive', namePattern: '^diminuitive', description: "-1 to attack rolls, +1 to defense rolls." },
        { cost: 4,  levelUp: 2, speed: 1, id: 'healer', namePattern: '^healer', description: "Increase health recovered with Healing techniques." },
        { cost: 1,  levelUp: 1, speed: 0, id: 'increasedLength', namePattern: '^increased length', description: "You occupy multiple spaces in a line." },
        { cost: 1,  levelUp: 0, speed: 0, id: 'largeHead', namePattern: '^large head', description: "Your head takes up more space." },
        { cost: 4,  levelUp: 3, speed: 0, id: 'limitedRegeneration', namePattern: '^limited regen', description: "Recover health each round, but if you take damage from a certain element, your regeneration is blocked that round." },
        { cost: 1,  levelUp: 0, speed: 0, id: 'longTail', namePattern: '^long tail', description: "Your tail takes up more spaces." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'morale', namePattern: '^morale', description: "Can use Valor like an Elite." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'hardenedResolve', namePattern: '^hardened resolve', description: "If you have no Valor, you can still use techniques or skills that require Valor." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'standTall', namePattern: '^stand tall', description: "You cannot be knocked prone." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'terrainAdaptation', namePattern: '^terrain adapt', description: "You aren't slowed down by rough terrain." },
        { cost: 12, levelUp: 0, speed: 0, id: 'ultimateAttack', namePattern: '^ultimate attack', description: "Gains one Ultimate Technique." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'unscrupulous', namePattern: '^unscrupulous', description: "You aren't incapacitated until -20 Valor." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'alteredDurability', namePattern: '^altered durability', description: "The required Core Level for a technique to defeat you is increased." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'amphibious', namePattern: '^amphibious', description: "Suffer no roll penalties while out of water." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'destructiveBurrow', namePattern: '^destructive burrow', description: "Spaces you burrow through become Rough Terrain." },
        { cost: 6,  levelUp: 3, speed: 1, id: 'durableFlunky', namePattern: '^durable flunky', description: "You cannot be defeated by a technique with too low a Core Level." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'freeBurrow', namePattern: '^free burrow', description: "Burrowing costs no Stamina." },
        { cost: 4,  levelUp: 0, speed: 0, id: 'landAdaptation', namePattern: '^land adapt', description: "Don't lose Valor or Health from being outside of water." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'resurrectingFlunky', namePattern: '^resurrecting flunky', description: "Revive at the start of your turn, unless attacked again while defeated." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'trample', namePattern: '^trample', description: "You can move over smaller enemies, dealing a Damage Increment of damage to them." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'toweringPresence', namePattern: '^towering presence', description: "Ignore the Zones of Control of smaller enemies." },
        { cost: 2,  levelUp: 2, speed: 0, id: 'burrow', namePattern: '^burrow', description: "Burrow underground, getting +1 to defense rolls against Ranged or Line attacks. Ignore terrain until you surface." },
        { cost: 3,  levelUp: 0, speed: 0, id: 'humanshape', namePattern: '^human( )?shape', description: "Assume the form of a human." },
        { cost: 4,  levelUp: 2, speed: 0, id: 'limitedFlight', namePattern: '^limited flight', description: "Gain +1 to defense rolls against techniques that wouldn't be able to hit flying targets." },
        { cost: 6,  levelUp: 0, speed: 0, rollStats: ['mus', 'aur', 'res'], id: 'pressingSwarm', namePattern: '^pressing swarm', description: "On success, move targets inside the swarm with you." },
        { cost: 12, levelUp: 0, speed: 0, id: 'shapeshifter', namePattern: '^shapeshifter', description: "Swap between two different character sheets." },
        { cost: 1,  levelUp: 1, speed: 0, rollStats: ['mus', 'dex', 'aur', 'int', 'res'], id: 'skillCopy', namePattern: '^skill copy', description: "On success, copy a Skill from the target." },
        { cost: 3,  levelUp: 1, speed: 0, id: 'swiftStance', namePattern: '^swift stance', description: "While in this stance, increase Move but decrease Defense." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'victorAtAnyCost', namePattern: '^victor(y)? at any cost', description: "If you don't have 3 Valor, you can spend 5 Valor to Overdrive, falling into negative Valor." },
        { cost: 1,  levelUp: 1, speed: 0, id: 'increasedCompanionSize', namePattern: '^increased companion size', description: "Increase the size of your Companion." },
        { cost: 2,  levelUp: 0, speed: 0, id: 'changeAttributes', namePattern: '^change attr', description: "Your base attributes change in this form." },
        { cost: 2,  levelUp: 2, speed: 1, id: 'enhancedRange', namePattern: '^enhanced range', description: "+1 Range for each level of Ranged Technique." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'greatAccuracy', namePattern: '^great acc', description: "+1 to Attack Rolls." },
        { cost: 8,  levelUp: 0, speed: 0, id: 'greatEvasion', namePattern: '^great (evd|eva)', description: "+1 to Defense Rolls." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'powerfulBlow', namePattern: '^powerful blow', description: "All your techniques gain a level of Reposition." },
        { cost: 6,  levelUp: 0, speed: 0, id: 'longReach', namePattern: '^long reach', description: "Can attack enemies one space past your Zone of Control."}
    ];
    let coreLibrary = [
        { cost: 2, levelUp: 1, id: 'damage' },
        { cost: 1, levelUp: 1, id: 'barrier' },
        { cost: 0, levelUp: 2, id: 'boost' },
        { cost: 1, levelUp: 1, id: 'healing' },
        { cost: 1, levelUp: 1, id: 'shield' },
        { cost: 0, levelUp: 0, id: 'mimic' },
        { cost: 3, levelUp: 2, id: 'summoning' },
        { cost: 1, levelUp: 1, id: 'weaken' },
        { cost: 4, levelUp: 2, id: 'ultDamage' },
        { cost: 0, levelUp: 3, id: 'ultTransform' },
        { cost: 0, levelUp: 3, id: 'ultMimic' },
        { cost: 3, levelUp: 3, id: 'domain' }
    ];

    function calculateBaseAttributes() {
        log('VALOR - Recalculating Base Attributes');
        getAttrs(['level', 'str', 'agi', 'spr', 'mnd', 'gut'], function(values) {
            let level = parseInt(values.level);
            let str = parseInt(values.str);
            let agi = parseInt(values.agi);
            let spr = parseInt(values.spr);
            let mnd = parseInt(values.mnd);
            let gut = parseInt(values.gut);

            if(str > level + 7) {
                str = level + 7;
            }
            if(agi > level + 7) {
                agi = level + 7;
            }
            if(spr > level + 7) {
                spr = level + 7;
            }
            if(mnd > level + 7) {
                mnd = level + 7;
            }
            if(gut > level + 7) {
                gut = level + 7;
            }

            if(str < 1) {
                str = 1
            }
            if(agi < 1) {
                agi = 1
            }
            if(spr < 1) {
                spr = 1
            }
            if(mnd < 1) {
                mnd = 1
            }
            if(gut < 1) {
                gut = 1
            }

            let unspentAP = 22 + 3 * level - str - agi - spr - mnd - gut;

            // Set values
            setAttrs({
                str: str,
                agi: agi,
                spr: spr,
                mnd: mnd,
                gut: gut,
                unspentAP: unspentAP
            });
        });
    }

    function calculateActiveAttributes() {
        log('VALOR - Recalculating Active Attributes');
        getAttrs(['level', 'str', 'agi', 'spr', 'mnd', 'gut', 'type',
            'boostmus', 'boostdex', 'boostaur', 'boostint', 'boostres'], function(values) {
            const level = parseInt(values.level);
            const str = parseInt(values.str);
            const agi = parseInt(values.agi);
            const spr = parseInt(values.spr);
            const mnd = parseInt(values.mnd);
            const gut = parseInt(values.gut);

            let mus = Math.ceil((level + str) / 2);
            let dex = Math.ceil((level + agi) / 2);
            let aur = Math.ceil((level + spr) / 2);
            let int = Math.ceil((level + mnd) / 2);
            let res = Math.ceil((level + gut) / 2);

            const boostmus = values.boostmus == 'on';
            const boostdex = values.boostdex == 'on';
            const boostaur = values.boostaur == 'on';
            const boostint = values.boostint == 'on';
            const boostres = values.boostres == 'on';

            switch(values.type) {
                case 'flunky':
                case 'soldier':
                    mus--;
                    dex--;
                    aur--;
                    int--;
                    res--;
                    break;
            }

            if(boostmus) mus++;
            if(boostdex) dex++;
            if(boostaur) aur++;
            if(boostint) int++;
            if(boostres) res++;

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }

                        switch(skillName) {
                            case 'balancedFighter':
                                let stats = [mus, dex, aur, int, res];
                                let highestStat = Math.max(...stats);
                                if(mus < highestStat) {
                                    mus++;
                                }
                                if(dex < highestStat) {
                                    dex++;
                                }
                                if(aur < highestStat) {
                                    aur++;
                                }
                                if(int < highestStat) {
                                    int++;
                                }
                                if(res < highestStat) {
                                    res++;
                                }
                                break;
                        }
                    }

                    // Set values
                    setAttrs({
                        mus: mus,
                        dex: dex,
                        aur: aur,
                        int: int,
                        res: res
                    });
                });
            });
        });
    }

    function calculateBoostVisibility() {
        log('VALOR - Recalculating Boost Visibility');

        let canBoostMus = false;
        let canBoostDex = false;
        let canBoostAur = false;
        let canBoostInt = false;
        let canBoostRes = false;

        getSectionIDs('repeating_skills', function(sidarray) {
            let skillFieldNames = [];
            for(let i = 0; i < sidarray.length; i++) {
                skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
            }
            getAttrs(skillFieldNames, function(skillValues) {
                for(let i = 0; i < sidarray.length; i++) {
                    let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];

                    switch(skillName) {
                        case 'acceleration':
                            canBoostDex = true;
                            break;
                        case 'analysis':
                            canBoostInt = true;
                            break;
                        case 'burningPassion':
                            canBoostRes = true;
                            break;
                        case 'resoluteAura':
                            canBoostAur = true;
                            break;
                        case 'strengthOfWill':
                            canBoostMus = true;
                            break;
                    }
                }

                let attrs = {};
                attrs['can_boost_mus'] = canBoostMus ? 'on' : 0;;
                attrs['can_boost_dex'] = canBoostDex ? 'on' : 0;;
                attrs['can_boost_aur'] = canBoostAur ? 'on' : 0;;
                attrs['can_boost_int'] = canBoostInt ? 'on' : 0;;
                attrs['can_boost_res'] = canBoostRes ? 'on' : 0;;

                // Set values
                setAttrs(attrs);
            });
        });
    }

    function calculateAttack() {
        log('VALOR - Recalculating Attack');
        getAttrs(['level', 'str', 'agi', 'spr', 'mnd', 'gut', 'type'], function(values) {
            let level = parseInt(values.level);
            let str = parseInt(values.str);
            let agi = parseInt(values.agi);
            let spr = parseInt(values.spr);
            let mnd = parseInt(values.mnd);
            let gut = parseInt(values.gut);

            let strAtk = (level + str) * 2;
            let agiAtk = (level + agi) * 2;
            let sprAtk = (level + spr) * 2;
            let mndAtk = (level + mnd) * 2;

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                            skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                        }

                        switch(skillName) {
                            case 'energyAttacker':
                                sprAtk += 3 + 3 * skillLevel;
                                mndAtk += 3 + 3 * skillLevel;
                                break;
                            case 'physicalAttacker':
                                strAtk += 3 + 3 * skillLevel;
                                agiAtk += 3 + 3 * skillLevel;
                                break;
                        }
                    }

                    switch(values.type) {
                        case 'flunky':
                        case 'soldier':
                        case 'swarm':
                            strAtk = Math.ceil(strAtk / 2);
                            agiAtk = Math.ceil(agiAtk / 2);
                            sprAtk = Math.ceil(sprAtk / 2);
                            mndAtk = Math.ceil(mndAtk / 2);
                            break;
                        case 'master':
                            strAtk += str;
                            agiAtk += agi;
                            sprAtk += spr;
                            mndAtk += mnd;
                            break;
                    }

                    // Set values
                    setAttrs({
                        strAtk: strAtk,
                        agiAtk: agiAtk,
                        sprAtk: sprAtk,
                        mndAtk: mndAtk
                    });
                });
            });
        });
    }

    function calculateHealth() {
        log('VALOR - Recalculating Max Health');
        getAttrs(['level', 'str', 'gut', 'type'], function(values) {
            let level = parseInt(values.level);
            let str = parseInt(values.str);
            let gut = parseInt(values.gut);

            let hp = 50 + 10 * level + 10 * gut + 5 * str;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']) {
                            flawLevel = parseInt(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'fragile':
                                hp -= 15 + 15 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                                    skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                                }

                                switch(skillName) {
                                    case 'tough':
                                        hp += 15 + 15 * skillLevel;
                                        break;
                                    case 'construct':
                                        hp += 2 * str;
                                        break;
                                }
                            }

                            switch(values.type) {
                                case 'flunky':
                                    hp = 1;
                                    break;
                                case 'soldier':
                                    hp = Math.ceil(hp / 2);
                                    break;
                                case 'master':
                                    hp *= 2;
                                    break;
                            }

                            // Set values
                            setAttrs({
                                hp_max: hp,
                                hpInc: Math.ceil(hp / 5),
                                hpCrit: Math.ceil(hp / 5) * 2
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateStamina() {
        log('VALOR - Recalculating Max Stamina');
        getAttrs(['level', 'mnd', 'spr', 'type'], function(values) {
            let level = parseInt(values.level);
            let mnd = parseInt(values.mnd);
            let spr = parseInt(values.spr);

            let st = 8 + 4 * level + 2 * spr + 2 * mnd;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']) {
                            flawLevel = parseInt(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'lackOfControl':
                                st -= 2 + 6 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                                    skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                                }

                                switch(skillName) {
                                    case 'tireless':
                                        st += 2 + 6 * skillLevel;
                                        break;
                                }
                            }

                            switch(values.type) {
                                case 'master':
                                    st *= 2;
                                    break;
                            }

                            // Set values
                            setAttrs({
                                st_max: st,
                                stInc: Math.ceil(st / 5)
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateDefense() {
        log('VALOR - Recalculating Defense');
        getAttrs(['level', 'str', 'gut', 'type'], function(values) {
            let level = parseInt(values.level);
            let str = parseInt(values.str);
            let gut = parseInt(values.gut);

            let defense = 2 * level + str + gut;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']) {
                            flawLevel = parseInt(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'weakDefender':
                                defense -= 2 + 2 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                                    skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                                }

                                switch(skillName) {
                                    case 'ironDefense':
                                        defense += 2 + 2 * skillLevel;
                                        break;
                                    case 'construct':
                                        defense += Math.ceil(level / 5) * 2;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                defense: defense
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateResistance() {
        log('VALOR - Recalculating Resistance');
        getAttrs(['level', 'spr', 'mnd', 'type'], function(values) {
            let level = parseInt(values.level);
            let spr = parseInt(values.spr);
            let mnd = parseInt(values.mnd);

            let resistance = 2 * level + spr + mnd;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']) {
                            flawLevel = parseInt(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'energyVulnerability':
                                resistance -= 2 + 2 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                                    skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                                }

                                switch(skillName) {
                                    case 'resistant':
                                        resistance += 2 + 2 * skillLevel;
                                        break;
                                    case 'construct':
                                        resistance -= Math.ceil(level / 5) * 2;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                resistance: resistance
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateSpeed() {
        log('VALOR - Recalculating Move');
        getAttrs(['agi'], function(values) {
            let agi = parseInt(values.agi);

            let speed = Math.ceil(agi / 4) + 2;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']) {
                            flawLevel = parseInt(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'slow':
                                speed -= flawLevel;
                                break;
                            case 'immobile':
                                speed = 0;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                                    skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                                }

                                switch(skillName) {
                                    case 'sprinter':
                                        speed += skillLevel;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                speed: speed
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateDamageIncrement() {
        log('VALOR - Recalculating Damage Increment');
        getAttrs(['level', 'type'], function(values) {
            let level = parseInt(values.level);

            let di = level + 5;

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                            skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                        }

                        switch(skillName) {
                            case 'improvedDamageIncrement':
                                di += 2 + 2 * skillLevel; // ERRATA: More powerful IDI
                                break;
                        }
                    }

                    switch(values.type) {
                        case 'flunky':
                        case 'soldier':
                            di = Math.ceil(di / 2);
                            break;
                    }

                    // Set values
                    setAttrs({
                        di: di
                    });
                });
            });
        });
    }

    function calculateInitiative() {
        log('VALOR - Recalculating Initiative');
        getAttrs(['dex'], function(values) {
            let init = parseInt(values.dex);

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'slowToAct':
                                init -= 2;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }

                                switch(skillName) {
                                    case 'quickToAct':
                                        init += 2;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                init: init
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateBonuses() {
        log('VALOR - Recalculating Attack/Defense Bonuses');
        getAttrs(['type'], function(values) {

            let atkBonus = 0;
            let defBonus = 0;

            if(values.type == 'master') {
                atkBonus++;
            }

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                            skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                        }

                        switch(skillName) {
                            case 'increasedSize':
                                atkBonus++;
                                defBonus--;
                                break;
                            case 'diminuitive':
                                atkBonus--;
                                defBonus++;
                                break;
                        }
                    }

                    let atkBonusDisp = ' ';
                    if(atkBonus > 0) atkBonusDisp = '+' + atkBonus;
                    if(atkBonus < 0) atkBonusDisp = atkBonus;
                    let defBonusDisp = ' ';
                    if(defBonus > 0) defBonusDisp = '+' + defBonus;
                    if(defBonus < 0) defBonusDisp = defBonus;

                    // Set values
                    setAttrs({
                        iatkrollbonus: atkBonus,
                        idefrollbonus: defBonus,
                        iatkrollbonusdisp: atkBonusDisp,
                        idefrollbonusdisp: defBonusDisp,
                    });
                });
            });
        });
    }

    // Utility function that unpacks camelcase into a display name.
    function getDisplayName(name) {
        return name
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, function(str) { return str.toUpperCase(); });
    }

    function calculateFlawsAndSkills() {
        log('VALOR - Recalculating Flaws & Skills');
        getAttrs(['level', 'type'], function(values) {
            var level = parseInt(values.level);
            var unspentSP = 14 + 6 * level;

            // Various values determined solely by skill list
            var valor = 10;
            var hasDigDeep = false;
            var hasOverloadLimits = false;
            var hasEmpowerAttack = false;
            var hasResoluteStrike = false;
            var hasUlt = false;
            var healerLevel = 0;

            switch(values.type) {
                case 'flunky':
                case 'soldier':
                    unspentSP = Math.ceil(unspentSP / 2);
                    break;
                case 'master':
                    unspentSP += 4 + level;
                    break;
            }

            // Apply Flaws
            var flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(var i = 0; i < idarray.length; i++) {
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawname');
                    flawFieldNames.push('repeating_flaws_' + idarray[i] + '_flawlevel');
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    var flawSP = 0;
                    for(var i = 0; i < idarray.length; i++) {
                        var warning = ' ';
                        var flawName = flawValues['repeating_flaws_' + idarray[i] + '_flawname'];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        var flawLevel = 1;
                        if(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']) {
                            flawLevel = parseInt(flawValues['repeating_flaws_' + idarray[i] + '_flawlevel']);
                        }

                        var flaw = flawLibrary.find(function(f) {
                            return f.id == flawName;
                        });

                        if(flaw) {
                            var flawMaxLevel = 1;
                            switch(flaw.speed) {
                                case 1:
                                    flawMaxLevel = Math.ceil(level / 5);
                                    break;
                                case 2:
                                    flawMaxLevel = Math.ceil(level / 3);
                                    break;
                                case 3:
                                    flawMaxLevel = 100; // Custom Flaw
                            }
                            if(flawLevel > flawMaxLevel && flaw.speed != 3) {
                                warning = 'Warning: Level cap for this Flaw is ' + flawMaxLevel + '.';
                            }

                            var flawAttrs = {};
                            flawAttrs['repeating_flaws_' + idarray[i] + '_warning'] = warning;
                            setAttrs(flawAttrs, { silent: true });

                            flawSP += flaw.cost + (flawLevel - 1) * flaw.levelUp;
                        }
                    }

                    // Gain SP from Flaws
                    if(flawSP > level + 7) {
                        flawSP = level + 7;
                    }
                    unspentSP += flawSP;

                    // Apply Skills
                    var skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(var i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                            skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(var i = 0; i < sidarray.length; i++) {
                                var warning = ' ';
                                var skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                var skillLevel = 1;
                                if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                                    skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                                }

                                switch(skillName) {
                                    case 'breakValorLimit':
                                        valor += 10;
                                        break;
                                    case 'digDeep':
                                        hasDigDeep = true;
                                        break;
                                    case 'empowerAttack':
                                        hasEmpowerAttack = true;
                                        break;
                                    case 'resoluteStrike':
                                        hasResoluteStrike = true;
                                        break;
                                    case 'overloadLimits':
                                        hasOverloadLimits = true;
                                        break;
                                    case 'healer':
                                        healerLevel = skillLevel;
                                        break;
                                }

                                var skill = skillLibrary.find(function(s) {
                                    return s.id == skillName;
                                });

                                if(skill) {
                                    var skillMaxLevel = 1;
                                    switch(skill.speed) {
                                        case 1:
                                            skillMaxLevel = Math.ceil(level / 5);
                                            break;
                                        case 2:
                                            skillMaxLevel = Math.ceil(level / 3);
                                            break;
                                        case 3:
                                            skillMaxLevel = 100; // Custom Skill
                                    }

                                    if(skillLevel > skillMaxLevel && skill.level != 3) {
                                        warning = 'Warning: Level cap for this Skill is ' + skillMaxLevel + '.';
                                    }

                                    var skillAttrs = {};
                                    skillAttrs['repeating_skills_' + sidarray[i] + '_warning'] = warning;
                                    setAttrs(skillAttrs, { silent: true });

                                    unspentSP -= skill.cost + (skillLevel - 1) * skill.levelUp;
                                }
                            }

                            // Set values
                            setAttrs({
                                unspentSP: unspentSP,
                                valor_max: valor,
                                hasDigDeep: hasDigDeep,
                                hasOverloadLimits: hasOverloadLimits,
                                hasEmpowerAttack: hasEmpowerAttack,
                                hasResoluteStrike: hasResoluteStrike,
                                healerLevel: healerLevel,
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateTP() {
        log('VALOR - Recalculating Unspent TP');
        getAttrs(['level', 'type'], function(values) {
            let level = parseInt(values.level);

            let unspentTP = 8 + 4 * level;
            let flunkyTP = 2 + level;
            let soldierTP = 4 + 2 * level;
            if(level > 5) {
                unspentTP += level - 5;
                flunkyTP += level - 5;
                soldierTP += level - 5;
            }
            if(level > 10) {
                unspentTP += level - 10;
            }
            if(level > 15) {
                unspentTP += level - 15;
                soldierTP += level - 15;
            }

            let hasUlt = false;

            switch(values.type) {
                case 'flunky':
                    unspentTP = flunkyTP;
                    break;
                case 'soldier':
                case 'swarm':
                    unspentTP = soldierTP;
                    break;
                case 'master':
                    unspentTP += 1 + level;
                    break;

            }

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skillname');
                    skillFieldNames.push('repeating_skills_' + sidarray[i] + '_skilllevel');
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues['repeating_skills_' + sidarray[i] + '_skillname'];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']) {
                            skillLevel = parseInt(skillValues['repeating_skills_' + sidarray[i] + '_skilllevel']);
                        }

                        switch(skillName) {
                            case 'versatileFighter':
                                switch(values.type) {
                                    case 'flunky':
                                        unspentTP += skillLevel;
                                        break;
                                    case 'soldier':
                                    case 'swarm':
                                        unspentTP += 2 + skillLevel;
                                        break;
                                    default:
                                        unspentTP += 2 + 2 * skillLevel;
                                        break;
                                }
                                break;
                            case 'ultimateAttack':
                                hasUlt = true;
                                break;
                        }
                    }

                    // Apply techs
                    let techFieldNames = [];
                    getSectionIDs('repeating_techs', function(tidarray) {
                        for(let i = 0; i < tidarray.length; i++) {
                            techFieldNames.push('repeating_techs_' + tidarray[i] + '_tech_core_level');
                            techFieldNames.push('repeating_techs_' + tidarray[i] + '_tech_mod_level');
                            techFieldNames.push('repeating_techs_' + tidarray[i] + '_tech_core');
                        }

                        getAttrs(techFieldNames, function(techValues) {

                            let ults = [];
                            if(level >= 5) {
                                ults.push(8);
                            }
                            if(level >= 10) {
                                ults.push(13);
                            }
                            if(level >= 15) {
                                ults.push(18);
                            }
                            if(level >= 20) {
                                ults.push(23);
                            }
                            if(hasUlt) {
                                ults.push(level);
                            }

                            for(let i = 0; i < tidarray.length; i++) {
                                techCore = techValues['repeating_techs_' + tidarray[i] + '_tech_core'];
                                let techCoreLevel = 1;
                                if(techValues['repeating_techs_' + tidarray[i] + '_tech_core_level']) {
                                    techCoreLevel = parseInt(techValues['repeating_techs_' + tidarray[i] + '_tech_core_level']);
                                }
                                let techModsLevel = 0;
                                if(techValues['repeating_techs_' + tidarray[i] + '_tech_mod_level']) {
                                    techModsLevel = parseInt(techValues['repeating_techs_' + tidarray[i] + '_tech_mod_level']);
                                }

                                let spentTP = techModsLevel + techCoreLevel;

                                // Set the tech's total level
                                let techAttrs = {};
                                techAttrs['repeating_techs_' + tidarray[i] + '_tech_level'] = spentTP;
                                setAttrs(techAttrs);

                                if((techCore == 'ultDamage' || techCore == 'ultTransform' || techCore == 'ultMimic' || techCore == 'domain')
                                    && ults.length > 0) {
                                    // Use the next Ult to offset the TP cost
                                    spentTP -= ults[0];
                                    ults.splice(0,1);
                                }

                                if(spentTP > 0) {
                                    unspentTP -= spentTP;
                                }
                            }

                            // Set values
                            setAttrs({
                                unspentTP: unspentTP
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateTechCommand(techId) {
        log('VALOR - Recalculating Technique Command ID ' + techId);

        let techFieldNames = [];

        techFieldNames.push('repeating_techs_' + techId + '_tech_name');
        techFieldNames.push('repeating_techs_' + techId + '_tech_core');
        techFieldNames.push('repeating_techs_' + techId + '_tech_mods');
        techFieldNames.push('repeating_techs_' + techId + '_tech_limits');
        techFieldNames.push('repeating_techs_' + techId + '_tech_targets');
        techFieldNames.push('repeating_techs_' + techId + '_tech_bonus');

        getAttrs(techFieldNames, function(techValues) {
            let techName = techValues['repeating_techs_' + techId + '_tech_name'];
            let techCore = 'damage';
            if(techValues['repeating_techs_' + techId + '_tech_core']) {
                techCore = techValues['repeating_techs_' + techId + '_tech_core'];
            }
            let techMods = '';
            if(techValues['repeating_techs_' + techId + '_tech_mods']) {
                techMods = techValues['repeating_techs_' + techId + '_tech_mods'].toLowerCase();
            }
            let techLimits = '';
            if(techValues['repeating_techs_' + techId + '_tech_limits']) {
                techLimits = techValues['repeating_techs_' + techId + '_tech_limits'].toLowerCase();
            }
            let techTargets = 1;
            if(techValues['repeating_techs_' + techId + '_tech_targets']) {
                techTargets = parseInt(techValues['repeating_techs_' + techId + '_tech_targets']);
            }
            if(techTargets > 20) {
                techTargets = 20;
            }
            let techBonus = 0;
            if(techValues['repeating_techs_' + techId + '_tech_bonus']) {
                techBonus = parseInt(techValues['repeating_techs_' + techId + '_tech_bonus']);
            }

            let hasTargets = true;

            if(techCore == 'barrier' || techCore == 'summoning' ||
               techCore == 'ultTransform' || techCore == 'domain') {
                hasTargets = false;
            }

            if(techMods.indexOf('custom') == -1 && techMods.indexOf('transform ally') > -1) {
                hasTargets = true;
            }

            if(techLimits.indexOf('custom') == -1 && techLimits.indexOf('self') > -1) {
                hasTargets = false;
            }

            let techCommand = '!t --as "@{character_id}" "@{tech_name}"';
            if(techBonus) {
                 techCommand += ' +@{tech_bonus}';
            }
            if(techTargets > 0 && hasTargets) {
                techCommand += ' --targets'
                for(let j = 0; j < techTargets; j++) {
                    let targetId = 'Target #' + (j + 1);
                    techCommand += ' @{target|' + targetId + '|token_id}'
                }
            }

            let attrs = {};
            attrs['repeating_techs_' + techId + '_tech_command'] = techCommand;
            setAttrs(attrs, { silent: true });
        });
    }

    function calculateTech(techId) {
        log('VALOR - Recalculating Technique ID ' + techId);

        let techFieldNames = ['str', 'agi', 'spr', 'mnd', 'gut',
                              'mus', 'dex', 'aur', 'int', 'res',
                              'strAtk', 'agiAtk', 'sprAtk', 'mndAtk',
                              'level', 'hp_max', 'di', 'type',
                              'hasDigDeep', 'hasOverloadLimits', 'hasEmpowerAttack', 'hasResoluteStrike', 'healerLevel'];

        techFieldNames.push(`repeating_techs_${techId}_tech_name`);
        techFieldNames.push(`repeating_techs_${techId}_tech_core_level`);
        techFieldNames.push(`repeating_techs_${techId}_tech_core`);
        techFieldNames.push(`repeating_techs_${techId}_tech_stat`);
        techFieldNames.push(`repeating_techs_${techId}_tech_mods`);
        techFieldNames.push(`repeating_techs_${techId}_tech_limits`);
        techFieldNames.push(`repeating_techs_${techId}_tech_description`);
        techFieldNames.push(`repeating_techs_${techId}_tech_shield_type`);
        techFieldNames.push(`repeating_techs_${techId}_tech_granted_skills`);
        techFieldNames.push(`repeating_techs_${techId}_tech_inflicted_flaws`);
        techFieldNames.push(`repeating_techs_${techId}_tech_targets`);
        techFieldNames.push(`repeating_techs_${techId}_tech_custom_cost`);

        getAttrs(techFieldNames, function(techValues) {
            let level = parseInt(techValues.level);
            let hp = parseInt(techValues.hp_max);
            let di = parseInt(techValues.di);
            let str = parseInt(techValues.str);
            let agi = parseInt(techValues.agi);
            let spr = parseInt(techValues.spr);
            let mnd = parseInt(techValues.mnd);
            let gut = parseInt(techValues.gut);

            let techName = techValues[`repeating_techs_${techId}_tech_name`];
            let techStat = techValues[`repeating_techs_${techId}_tech_stat`];
            let techShieldType = techValues[`repeating_techs_${techId}_tech_shield_type`];
            let techGrantedSkills = techValues[`repeating_techs_${techId}_tech_granted_skills`];
            let techInflictedFlaws = techValues[`repeating_techs_${techId}_tech_inflicted_flaws`];
            let techDescription = techValues[`repeating_techs_${techId}_tech_description`];
            let techCore = 'damage';
            if(techValues[`repeating_techs_${techId}_tech_core`]) {
                techCore = techValues[`repeating_techs_${techId}_tech_core`];
            }
            let techMods = '';
            if(techValues[`repeating_techs_${techId}_tech_mods`]) {
                techMods = techValues[`repeating_techs_${techId}_tech_mods`].toLowerCase();
            }
            let techLimits = '';
            if(techValues[`repeating_techs_${techId}_tech_limits`]) {
                techLimits = techValues['repeating_techs_' + techId + '_tech_limits'].toLowerCase();
            }
            let techCoreLevel = 1;
            if(techValues[`repeating_techs_${techId}_tech_core_level`]) {
                techCoreLevel = parseInt(techValues[`repeating_techs_${techId}_tech_core_level`]);
            }
            let techTargets = 1;
            if(techValues['repeating_techs_' + techId + '_tech_targets']) {
                techTargets = parseInt(techValues[`repeating_techs_${techId}_tech_targets`]);
            }
            if(techTargets > 20) {
                techTargets = 20;
            }
            let techCustomCost = 0;
            if(techValues[`repeating_techs_${techId}_tech_custom_cost`]) {
                techCustomCost = parseInt(techValues[`repeating_techs_${techId}_tech_custom_cost`]);
            }

            // Build tech summary
            let summary = '';
            let warnings = [];

            let hasSkills = false;
            let hasFlaws = false;
            let barrierFreebie = false;
            let isPersistent = false;
            let isThrow = false;
            let hasSpecialAttack = false;

            if(techCoreLevel < 1) {
                warnings.push('Core Power cannot be less than 1.');
            }

            // Is this an ult?
            if(techCore == 'ultDamage' || techCore == 'ultTransform' ||
               techCore == 'ultMimic' || techCore == 'domain') {
                summary += 'Ultimate Technique. ';
            }

            // Display required action
            let action = 'Attack';
            if(techCore == 'barrier' || techCore == 'boost' ||
               techCore == 'healing' || techCore == 'weaken' ||
               techCore == 'shield' || techCore == 'ultTransform') {
                action  = 'Support';
            }
            if(techMods.indexOf('rush') > -1 || techMods.indexOf('ramming') > -1) {
                action += '+Move';
            }
            if((techCore == 'summoning' && techMods.indexOf('quick summon') == -1) || techLimits.indexOf('slow') > -1) {
                action = 'Slow';
            }
            if(techCore != 'custom') {
                summary += action + ' Action. ';
            }

            // Display core functionality
            let rollStat = techStat;
            if(techMods.indexOf('muscular') > -1) {
                rollStat = 'str';
            }
            if(techMods.indexOf('dexterous') > -1 ||
               techMods.indexOf('dextrous') > -1) {
                rollStat = 'agi';
            }
            if(techMods.indexOf('aura') > -1) {
                rollStat = 'spr';
            }
            if(techMods.indexOf('intuitive') > -1) {
                rollStat = 'mnd';
            }
            if(techCore == 'damage' ||
               techCore == 'ultDamage' ||
               techCore == 'weaken' ||
               techCore == 'custom') {
                let hitBonus = 0;
                if(techMods.indexOf('accurate') > -1) {
                    hitBonus += 2;
                }
                if(techLimits.indexOf('final') > -1) {
                    hitBonus += 5;
                }
                let toHit = 0;
                switch(rollStat) {
                    case 'str':
                        toHit = techValues.mus + hitBonus;
                        summary += 'Roll Muscle (1d10+' + toHit + ') to hit. '
                        break;
                    case 'agi':
                        toHit = techValues.dex + hitBonus;
                        summary += 'Roll Dexterity (1d10+' + toHit + ') to hit. '
                        break;
                    case 'spr':
                        toHit = techValues.aur + hitBonus;
                        summary += 'Roll Aura (1d10+' + toHit + ') to hit. '
                        break;
                    case 'mnd':
                        toHit = techValues.int + hitBonus;
                        summary += 'Roll Intuition (1d10+' + toHit + ') to hit. '
                        break;
                    case 'gut':
                        toHit = techValues.res + hitBonus;
                        summary += 'Roll Resolve (1d10+' + toHit + ') to hit. '
                        break;
                }
            }
            switch(techCore) {
                case 'damage':
                case 'ultDamage':

                    // Get damage and stat for description
                    let specialAttack =
                        techMods.indexOf('sapping') > -1 ||
                        techMods.indexOf('piercing') > -1 ||
                        techMods.indexOf('drain') > -1 ||
                        techMods.indexOf('persistent') > -1 ||
                        techMods.indexOf('debilitating') > -1 ||
                        techMods.indexOf('boosting') > -1;
                    let damage = 0;
                    switch(techStat) {
                        case 'str':
                            if(specialAttack && techCore == 'damage') {
                                damage = 12 + 4 * techCoreLevel + Math.ceil(techValues.strAtk / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                damage = 15 + 5 * techCoreLevel + techValues.strAtk;
                            } else {
                                damage = 24 + 8 * techCoreLevel + techValues.strAtk;
                            }
                            summary += 'On a hit, deal ' + damage + ' physical damage to the target. '
                            break;
                        case 'agi':
                            if(specialAttack && techCore == 'damage') {
                                damage = 12 + 4 * techCoreLevel + Math.ceil(techValues.agiAtk / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                damage = 15 + 5 * techCoreLevel + techValues.agiAtk;
                            } else {
                                damage = 24 + 8 * techCoreLevel + techValues.agiAtk;
                            }
                            summary += 'On a hit, deal ' + damage + ' physical damage to the target. '
                            break;
                        case 'spr':
                            if(specialAttack && techCore == 'damage') {
                                damage = 12 + 4 * techCoreLevel + Math.ceil(techValues.sprAtk / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                damage = 15 + 5 * techCoreLevel + techValues.sprAtk;
                            } else {
                                damage = 24 + 8 * techCoreLevel + techValues.sprAtk;
                            }
                            summary += 'On a hit, deal ' + damage + ' energy damage to the target. '
                            break;
                        case 'mnd':
                            if(specialAttack && techCore == 'damage') {
                                damage = 12 + 4 * techCoreLevel + Math.ceil(techValues.mndAtk / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                damage = 15 + 5 * techCoreLevel + techValues.mndAtk;
                            } else {
                                damage = 24 + 8 * techCoreLevel + techValues.mndAtk;
                            }
                            summary += 'On a hit, deal ' + damage + ' energy damage to the target. '
                            break;
                    }
                    break;
                case 'healing':
                    let healing = 0;
                    switch(techStat) {
                        case 'spr':
                            healing = Math.ceil(spr / 2);
                            break;
                        case 'mnd':
                            healing = Math.ceil(mnd / 2);
                            break;
                        case 'gut':
                            healing = Math.ceil(gut / 2);
                            break;
                    }
                    if(techValues.healerLevel > 0) {
                        healing += 2 + 2 * techValues.healerLevel;
                    }
                    if(techMods.indexOf('continuous r') > -1) {
                        healing += 6 + 2 * techCoreLevel;
                        if(techValues.type == 'flunky' || techValues.type == 'soldier') healing = Math.ceil(healing / 2);
                        summary += 'Makes the target recover ' + healing + ' Health per turn for 3 turns. '
                    } else {
                        healing += 9 + 3 * techCoreLevel;
                        if(techValues.type == 'flunky' || techValues.type == 'soldier') healing = Math.ceil(healing / 2);
                        summary += 'Restore ' + healing + ' Health to the target. '
                    }
                    break;
                case 'shield':
                    let shield = 0;
                    switch(techStat) {
                        case 'spr':
                            shield = spr;
                            break;
                        case 'mnd':
                            shield = mnd;
                            break;
                        case 'gut':
                            shield = gut;
                            break;
                    }
                    shield += 12 + 4 * techCoreLevel;
                    if(techValues.type == 'flunky' || techValues.type == 'soldier') shield = Math.ceil(shield / 2);
                    
                    switch(techShieldType) {
                        case 'energy':
                            summary += `Grants the target an energy shield with ${shield} HP.`;
                            break;
                        case 'versatile':
                            summary += `Grants the target a versatile shield with ${shield} HP.`;
                            break;
                        default:
                            summary += `Grants the target a physical shield with ${shield} HP.`;
                            break;
                    }
                    break;
                case 'barrier':
                    summary += 'Create a Barrier of power ' + techCoreLevel + '. ';
                    barrierFreebie = true;
                    break;
                case 'mimic':
                    summary += 'Mimics a witnessed enemy Technique at Tech Level ' + techCoreLevel + '. ';
                    break;
                case 'ultMimic':
                    summary += 'Mimics a witnessed enemy Ultimate Technique at Tech Level ' + techCoreLevel + '. ';
                    break;
                case 'summoning':
                    summary += 'Summons a Level ' + techCoreLevel + ' ally. Command it with a Support Action. ';
                    break;
                case 'ultTransform':
                    let bonusHp = level * 10;
                    if(techValues.type == 'master') {
                        bonusHp *= 2;
                    }
                    summary += 'Transform, gaining ' + bonusHp + ' HP and +1 to all Active Attributes. ';
                    if(techGrantedSkills) {
                        summary += 'Grants Skills: ' + techGrantedSkills;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasSkills = true;
                    break;
                case 'boost':
                    if(techGrantedSkills) {
                        summary += 'Grants Skills: ' + techGrantedSkills;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasSkills = true;
                    break;
                case 'weaken':
                    if(techInflictedFlaws) {
                        summary += 'Inflicts Flaws: ' + techInflictedFlaws;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasFlaws = true;
                    break;
                case 'domain':
                    if(techGrantedSkills) {
                        summary += 'Grants Skills within domain: ' + techGrantedSkills;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    if(techInflictedFlaws) {
                        summary += ' Inflicts Flaws within domain: ' + techInflictedFlaws;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasSkills = true;
                    hasFlaws = true;
                    break;
                case 'custom':
                    hasSkills = true;
                    hasFlaws = true;
                    break;
                default:
                    warnings.push(`Unknown Core '${techCore}'.`);
                    break;
            }

            summary += '\n';

            // Display mods
            let totalModLevel = 0;
            let mods = techMods.split('\n');
            mods.forEach(function(mod) {
                // Try to get the level
                let split = mod.split(' ');
                let modLevel = parseInt(split[split.length - 1]);
                if(modLevel != modLevel) {
                    // NaN, so there's no level listed - assume 1
                    modLevel = 1;
                }

                if(mod.indexOf('custom') == 0) {
                    totalModLevel += modLevel;
                } else if(mod.indexOf('range') == 0) {
                    let range = 3 * modLevel;
                    switch(techStat) {
                        case 'str':
                            range = 2 * modLevel;
                            break;
                        case 'agi':
                        case 'spr':
                            range = 4 * modLevel;
                            break;
                    }
                    summary += 'Range ' + range + '. ';
                    totalModLevel += modLevel;
                } else if(mod.indexOf('blast') == 0) {
                    let rushMod = mods.find(function(m) {
                      return m.indexOf('line') > -1;
                    });
                    if(rushMod) {
                        // Say nothing - this'll get incorporated into the line attack mod
                    } else {
                        summary += 'Blast Radius ' + modLevel + '. ';
                    }
                    let blastCost = 0;
                    if(techStat == 'spr') {
                        blastCost = 2 * modLevel - 1;
                    } else {
                        blastCost = 2 * modLevel;
                    }
                    if(barrierFreebie) {
                        blastCost -= 2;
                        if(blastCost < 0) {
                            blastCost = 0;
                        }
                        barrierFreebie = false;
                    }
                    totalModLevel += blastCost;
                } else if(mod.indexOf('chain') == 0) {
                    if(modLevel == 1) {
                        summary += 'Chains once. ';
                    } else if(modLevel == 2) {
                        summary += 'Chains twice. ';
                    } else {
                        summary += 'Chains ' + modLevel + ' times. ';
                    }
                    totalModLevel += modLevel;
                } else if(mod.indexOf('line') == 0 && mod.indexOf('line var') != 0) {
                    let line = 3 * modLevel;
                    switch(techStat) {
                        case 'str':
                        case 'agi':
                            line = 2 * modLevel;
                            break;
                        case 'spr':
                            line++;
                            break;
                    }

                    let blastMod = mods.find(function(m) {
                      return m.indexOf('blast') == 0;
                    });
                    if(blastMod) {
                        // Incorporate blast radius into line attack
                        let blastSplit = blastMod.split(' ');
                        let blastRadius = parseInt(blastSplit[blastSplit.length - 1]);
                        if(blastRadius != blastRadius) {
                            // NaN, so there's no level listed - assume 1
                            blastRadius = 1;
                        }
                        summary += 'Targets everything within radius ' + blastRadius + ' around a line of length ' + line + '. ';
                    } else {
                        summary += 'Targets in a line of length ' + line + '. ';
                    }
                    totalModLevel += modLevel;
                    if(barrierFreebie) {
                        totalModLevel--;
                        barrierFreebie = false;
                    }
                } else if(mod.indexOf('line var') == 0) {
                    let variations = modLevel;
                    if(techStat == 'mnd') {
                        variations++;
                    }
                    if(variations == 1) {
                        summary += 'Line can change direction once. ';
                    } else {
                        summary += 'Line can change direction ' + variations + ' times. ';
                    }
                    totalModLevel += modLevel;
                } else if(mod.indexOf('multiple') == 0) {
                    let targets = 1 + modLevel;
                    if(techStat == 'agi') {
                        targets++;
                    }
                    summary += 'Choose up to ' + targets + ' targets. ';
                    totalModLevel += modLevel;
                } else if(mod.indexOf('indirect') == 0) {
                    summary += 'Can target anywhere on the battlefield. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('rush') == 0) {
                    summary += 'Take a Move Action, then target everyone you moved through. ';
                    let dashMod = mods.find(function(m) {
                      return m.indexOf('dash') > -1;
                    });
                    if(dashMod) {
                      // Incorporate dash mod into rush attack
                      let dashSplit = dashMod.split(' ');
                      let bonusMove = parseInt(dashSplit[dashSplit.length - 1]);
                      if(bonusMove != bonusMove) {
                          // NaN, so there's no level listed - assume 1
                          bonusMove = 1;
                      }
                      if(techStat == 'agi') {
                          bonusMove++;
                      }
                      if(bonusMove == 1) {
                          summary += 'You can move an additional space on this Move Action. ';
                      } else {
                          summary += 'You can move an additional ' + bonusMove + ' spaces on this Move Action. ';
                      }
                    }
                    if(techStat == 'agi' || techStat == 'str') {
                        totalModLevel += 2;
                    } else {
                        totalModLevel += 3;
                    }
                } else if(mod.indexOf('smart area') == 0) {
                    summary += 'You can choose to omit any number of spaces from the target area. ';
                    if(techStat == 'mnd') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('whirlwind') == 0) {
                    summary += 'Targets all enemies in your Zone of Control. ';
                    if(techStat == 'str' || techStat == 'agi') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('debilitating') == 0) {
                    if(techInflictedFlaws) {
                        summary += 'Inflicts Flaws on a hit: ' + techInflictedFlaws + '. ';
                    }
                    hasFlaws = true;
                    if(hasSpecialAttack) {
                        warnings.push("Warning: Technique can't have multiple Special Attack modifiers.");
                    } else {
                        hasSpecialAttack = true;
                    }
                } else if(mod.indexOf('boosting') == 0) {
                    hasSkills = true;
                    if(hasSpecialAttack) {
                        warnings.push("Warning: Technique can't have multiple Special Attack modifiers.");
                    } else {
                        hasSpecialAttack = true;
                    }
                } else if(mod.indexOf('drain') == 0) {
                    summary += 'On a hit, recover Health equal to the largest amount of damage dealt to a single target. ';
                    if(hasSpecialAttack) {
                        warnings.push("Warning: Technique can't have multiple Special Attack modifiers.");
                    } else {
                        hasSpecialAttack = true;
                    }
                } else if(mod.indexOf('persistent') == 0) {
                    summary += 'Attacks again in the same area at the start of your next 2 turns. ';
                    isPersistent = true;
                    if(hasSpecialAttack) {
                        warnings.push("Warning: Technique can't have multiple Special Attack modifiers.");
                    } else {
                        hasSpecialAttack = true;
                    }
                } else if(mod.indexOf('piercing') == 0) {
                    if(techStat == 'str' || techStat == 'agi') {
                        summary += 'Ignores Defense. ';
                    } else {
                        summary += 'Ignores Resistance. ';
                    }
                    if(hasSpecialAttack) {
                        warnings.push("Warning: Technique can't have multiple Special Attack modifiers.");
                    } else {
                        hasSpecialAttack = true;
                    }
                } else if(mod.indexOf('sapping') == 0) {
                    summary += 'On a hit, the target takes ongoing damage equal to a third of initial damage for 3 turns. ';
                    if(hasSpecialAttack) {
                        warnings.push("Warning: Technique can't have multiple Special Attack modifiers.");
                    } else {
                        hasSpecialAttack = true;
                    }
                } else if(mod.indexOf('transform ally') == 0) {
                    summary += 'Can transform an ally within 5 spaces. ';
                    totalModLevel += 1;
                } else if(mod.indexOf('unerring') == 0) {
                    summary += 'Can be used again if you miss every target. ';
                    totalModLevel += 2;
                } else if(mod.indexOf('consecutive transform') == 0) {
                    summary += 'Can stack with another Transformation. ';
                    totalModLevel += modLevel;
                } else if(mod.indexOf('intimidating transform') == 0) {
                    summary += `When transforming and at the start of each turn, roll Resolve (1d10+${techValues.res}) or Aura (1d10+${techValues.aur})` +
                    ` to intimidate everyone within ${modLevel} spaces.`;
                    totalModLevel += modLevel;
                } else if(mod.indexOf('accurate') == 0) {
                    if(techStat == 'agi') {
                        totalModLevel += 3;
                    } else {
                        totalModLevel += 4;
                    }
                } else if(mod.indexOf('aura') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('damage shift') == 0) {
                    if(techStat == 'str' || techStat == 'agi') {
                        summary += 'Is affected by Resistance instead of Defense. ';
                    } else {
                        summary += 'Is affected by Defense instead of Resistance. ';
                    }
                    totalModLevel++;
                } else if(mod.indexOf('darkness zone') == 0) {
                    summary += 'Target area is filled with darkness. ';
                    totalModLevel += 2;
                } else if(mod.indexOf('dash') == 0) {
                    let rushMod = mods.find(function(m) {
                      return m.indexOf('rush') > -1;
                    });
                    if(rushMod) {
                        // Say nothing - this'll get incorporated into the rush mod
                    } else {
                        let distance = modLevel;
                        if(techStat == 'agi') {
                            distance++;
                        }
                        if(distance == 1) {
                            summary += 'Move 1 space before or after attacking. ';
                        } else {
                            summary += 'Move ' + distance + ' spaces before or after attacking. ';
                        }
                    }
                    totalModLevel += modLevel;
                } else if(mod.indexOf('destruction') == 0) {
                    let destroy = 2 * modLevel;
                    summary += '+' + destroy + ' Durability damage to objects. ';
                    totalModLevel += modLevel;
                } else if(mod.indexOf('dexterous') == 0 ||
                          mod.indexOf('dextrous') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('drop') == 0) {
                    summary += 'If target is flying, they fall and take ' + di + ' damage. ';
                    totalModLevel++;
                } else if(mod.indexOf('grant flaw') == 0 ||
                          mod.indexOf('grants flaw') == 0) {
                    if(techInflictedFlaws) {
                        summary += 'Inflicts Flaws: ' + techInflictedFlaws + '. ';
                    }
                    totalModLevel += modLevel;
                    hasFlaws = true;
                } else if(mod.indexOf('grant skill') == 0 ||
                          mod.indexOf('grants skill') == 0) {
                    if(techGrantedSkills) {
                        summary += 'Grants Skills: ' + techGrantedSkills + '. ';
                    }
                    totalModLevel += modLevel;
                    hasSkills = true;
                } else if(mod.indexOf('high barrier') == 0) {
                    summary += 'Flying targets cannot cross the barrier. ';
                    totalModLevel ++;
                } else if(mod.indexOf('immobiliz') == 0) {
                    summary += 'On a hit, the target is Immobilized. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('intuitive') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('knock') == 0) {
                    summary += 'On a hit, the target is knocked prone. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('light zone') == 0) {
                    summary += 'Darkness in the target area is eliminated. ';
                    totalModLevel++;
                } else if(mod.indexOf('muscular') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('ram') == 0) {
                    summary += 'On a hit, move and drag the target to a space adjacent to you. ';
                    if(techStat == 'str') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('repo') == 0) {
                    let distance = 1 + modLevel;
                    if(techStat == 'str') {
                        distance++;
                    }
                    summary += 'On a hit, move the target up to ' + distance + ' spaces. ';
                    totalModLevel += modLevel;
                } else if(mod.indexOf('throw') == 0) {
                    summary += 'If you move the target into someone else, attack them as well to deal full damage. ';
                    if(techStat == 'str') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                    isThrow = true;
                } else if(mod.indexOf('violent') == 0) {
                    summary += 'If someone tries to move through the barrier, they take ' + di + ' damage. ';
                    totalModLevel++;
                } else if(mod.indexOf('launching') == 0) {
                    summary += 'On a hit, the target is Launched. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('phasing') == 0) {
                    summary += 'Ignores all obstacles. ';
                    totalModLevel++;
                } else if(mod.indexOf('quick summon') == 0) {
                    totalModLevel += 3;
                } else if(mod.indexOf('selective barrier') == 0) {
                    summary += 'Allies can move through the barrier freely. ';
                    totalModLevel++;
                } else if(mod.indexOf('disrupt') >= 0) {
                    summary += 'Target area becomes Difficult Terrain. ';
                    totalModLevel++;
                } else if(mod.indexOf('repair') >= 0) {
                    summary += 'Difficult Terrain in the target area is eliminated. ';
                    totalModLevel++;
                } else if(mod.indexOf('element') == 0) {
                    summary += 'Deals elemental damage. ';
                    if(techStat == 'str' || techStat == 'agi') {
                        totalModLevel++;
                    }
                } else if(mod.indexOf('defeat lock') == 0) {
                    summary += "If target is incapacitated, they can't be revived for 24 hours unless this character is defeated. ";
                    totalModLevel += 3;
                } else if(mod.indexOf('draw out the dark') == 0) {
                    summary += "On a hit, targets with Malevolent Entity must make a roll to maintain control. ";
                    totalModLevel += 1;
                } else if(mod.indexOf('effect lock') == 0) {
                    summary += "If centered on a target, the area of effect follows them as they move. ";
                    totalModLevel += 2;
                } else if(mod.indexOf('encroaching mal') == 0) {
                    summary += "On a hit, the target gains 1 Malevolence. ";
                    totalModLevel += 1;
                } else if(mod.indexOf('intimidat') == 0) {
                    summary += "On a hit, the target is Shaken. ";
                    totalModLevel += 3;
                } else if(mod.indexOf('overwhelming mal') == 0) {
                    summary += "On a hit, the target gains 1 Malevolence that lasts until the next rest scene. ";
                    totalModLevel += 3;
                } else if(mod.indexOf('pull under') == 0) {
                    summary += "On a hit, the target is dragged underwater. ";
                    totalModLevel += 2;
                } else if(mod.indexOf('repair') == 0) {
                    summary += "Can heal undead and constructs. ";
                    totalModLevel += 2;
                } else if(mod.indexOf('targeting mark') == 0) {
                    summary += "On a hit, Mark the target, giving your allies +1 to hit that target for 3 turns. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('astral form') == 0) {
                    summary += "Project an astral body into the center of the domain; you can attack from it and it projects a Zone of Control. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('astral mo') == 0) {
                    summary += "Your astral body can move within your domain whenever you move. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('influential control') == 0) {
                    if(limitLevel == 1) {
                        summary += "Your zone of control is expanded by 1 space within your domain. ";
                    } else {
                        summary += "Your zone of control is expanded by " + modLevel + " spaces within your domain. ";
                    }
                    totalModLevel += 6 * limitLevel;
                } else if(mod.indexOf('locked domain') == 0) {
                    summary += "Characters must succeed at an opposed roll against you to exit your domain. Attacks across the edge of the domain are made at a -2 penalty. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('shifting tran') == 0) {
                    summary += "Switch to another form and replace one of its Transformations with this one. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('shifting dom') == 0) {
                    summary += "Switch to another form and replace one of its Domains with this one. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('touch of mal') == 0) {
                    summary += "Whenever you hit a target with a Damage or Weaken tech in this form, they gain 1 Malevolence. ";
                    totalModLevel += 6;
                } else if(mod.indexOf('continuous r') == 0) {
                    // Add nothing, already explained in core description
                } else if(mod.length > 0) {
                    warnings.push(`Unrecognized Modifier '${mod}'.`);
                }
            });
            if(techCore == 'ultDamage' || techCore == 'domain') {
                totalModLevel -= 2;
                if(totalModLevel < 0) totalModLevel = 0;
                totalModLevel = Math.ceil(totalModLevel / 2);
            }

            let techLevel = techCoreLevel + totalModLevel;
            if(techLevel > level + 3 || (techCoreLevel > level && techCore == 'summoning')) {
                warnings.push('Technique Level is too high for current Character Level.');
            }

            summary += '\n';
            // Display the technique cost and limits
            let core = coreLibrary.find(function(c) {
                return c.id == techCore;
            });

            let limitSummary = '';
            let limitSt = 0;
            let limits = techLimits.split('\n');
            limits.forEach(function(limit) {
                // Try to get the level
                let split = limit.split(' ');
                let limitLevel = parseInt(split[split.length - 1]);
                if(limitLevel != limitLevel) {
                    // NaN, so there's no level listed - assume 1
                    limitLevel = 1;
                }

                if(limit.indexOf('custom') == 0) {
                    limitSt += limitLevel;
                } else if(limit.indexOf('health') == 0) {
                    let healthLost = 5 * limitLevel;
                    limitSummary += 'Costs ' + healthLost + ' Health. ';
                    limitSt += 2 * limitLevel;
                    if(limitLevel > 5) {
                        warnings.push("Health Limit can't be taken above level 5.");
                    }
                } else if(limit.indexOf('ally') == 0) {
                    limitSummary += 'Cannot target yourself. ';
                    limitSt++;
                } else if(limit.indexOf('ammo') == 0 ||
                          limit.indexOf('ammunition') == 0) {
                    let ammo = 4 - limitLevel;
                    if(ammo == 1) {
                        limitSummary += 'Can only be used once per scene. ';
                    } else {
                        limitSummary += 'Can only be used ' + ammo + ' times per scene. ';
                    }
                    limitSt += 3 * limitLevel;
                } else if(limit.indexOf('companion') == 0) {
                    limitSummary += 'Only your Companion can use this Technique. ';
                    limitSt += 2;
                } else if(limit.indexOf('cooldown') == 0) {
                    if(limitLevel == 1) {
                        limitSummary += 'Must wait for 1 turn before using again. ';
                    } else {
                        limitSummary += 'Must wait for ' + limitLevel + ' turns before using again. ';
                    }
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('dark power') == 0) {
                    limitSummary += 'When you use this Technique, make a Malevolent Entity check. ';
                    limitSt += 10;
                } else if(limit.indexOf('form') == 0) {
                    limitSummary += 'You must be transformed to use this Technique. ';
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('falling') == 0) {
                    limitSummary += 'Fall prone after using this Technique. ';
                    limitSt += 4;
                } else if(limit.indexOf('grant flaw') == 0) {
                    if(techInflictedFlaws) {
                        summary += 'Inflicts Flaws on user: ' + techInflictedFlaws + '. ';
                    }
                    limitSt += limitLevel;
                    hasFlaws = true;
                } else if(limit.indexOf('grant skill') == 0) {
                    if(techGrantedSkills) {
                        summary += 'Grants Skills for target: ' + techGrantedSkills + '. ';
                    }
                    limitSt += limitLevel;
                    hasSkills = true;
                } else if(limit.indexOf('initiative') == 0) {
                    limitSummary += 'Initiative reduced by ' + limitLevel + ' after using this Technique. ';
                    limitSt += 3 * limitLevel;
                } else if(limit.indexOf('immobile') == 0) {
                    limitSummary += "Can't be used if you've already moved this turn. ";
                    limitSt += 3;
                } else if(limit.indexOf('injury') == 0) {
                    let threshold = hp - Math.ceil(hp / 5) * limitLevel;
                    limitSummary += 'Your Health must be ' + threshold + ' or lower to use this Technique. ';
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('landbound') == 0) {
                    limitSummary += 'Cannot target flying characters. ';
                    limitSt++;
                } else if(limit.indexOf('mercy') == 0) {
                    limitSummary += 'Cannot reduce a target below 1 HP. ';
                    limitSt += 3;
                } else if(limit.indexOf('minimum range') == 0) {
                    limitSummary += 'Cannot target characters who are ' + limitLevel + ' or fewer spaces away from you. ';
                    limitSt += limitLevel;
                } else if(limit.indexOf('movement') == 0) {
                    if(limitLevel == 1) {
                        limitSummary += "Can't be used unless you're at least 1 space away from where you started your turn. ";
                    } else {
                        limitSummary += "Can't be used unless you're at least " + limitLevel + ' spaces away from where you started your turn. ';
                    }
                    limitSt += limitLevel;
                } else if(limit.indexOf('push') == 0) {
                    limitSummary += 'Each space of movement must move the target further away from you. ';
                    limitSt++;
                } else if(limit.indexOf('pull') == 0) {
                    limitSummary += 'Each space of movement must move the target closer to you. ';
                    limitSt++;
                } else if(limit.indexOf('reaction') == 0) {
                    limitSummary += 'Can only be used with the Counterattack skill. ';
                    limitSt += 3;
                } else if(limit.indexOf('reload') == 0) {
                    limitSummary += 'Must use a Support Action to reload before using again. ';
                    limitSt += 4;
                } else if(limit.indexOf('sequence') == 0) {
                    limitSummary += 'Must use a specific other Technique before using this one. ';
                    limitSt += 4;
                } else if(limit.indexOf('self') == 0) {
                    limitSummary += 'Can only target yourself. ';
                    limitSt++;
                } else if(limit.indexOf('setup') == 0 ||
                          limit.indexOf('set-up') == 0 ||
                          limit.indexOf('set up') == 0) {
                    let turn = 1 + limitLevel;
                    limitSummary += "Can't be used until turn " + turn + ' or later. ';
                    limitSt += limitLevel;
                } else if(limit.indexOf('single companion') == 0) {
                    limitSummary += 'Only a specific Companion can use this Technique. ';
                    limitSt += 3;
                } else if(limit.indexOf('slow') == 0) {
                    limitSt += 6;
                } else if(limit.indexOf('temporary') == 0) {
                    limitSummary += 'Only lasts for 2 turns. ';
                    limitSt += 6;
                } else if(limit.indexOf('unstable summon') == 0) {
                    limitSummary += 'Summon has a ' + limitLevel + ' in 10 chance to ignore orders. ';
                    limitSt += 4 * limitLevel;
                } else if(limit.indexOf('upkeep') == 0) {
                    limitSummary += 'Must spent ' + limitLevel + ' Stamina at the start of each turn to keep active. ';
                    limitSt += 4 * limitLevel;
                } else if(limit.indexOf('vitality') == 0) {
                    let threshold = Math.ceil(hp * 0.4);
                    limitSummary += "Can't be used if you are at or below " + threshold + ' Health. ';
                    limitSt += 3 * limitLevel;
                } else if(limit.indexOf('valor') == 0) {
                    if(limit.indexOf('valor consumption') > -1) {
                        limitSummary += 'Valor is reduced by ' + limitLevel + ' after using (can go below 0). ';
                        limitSt += 5 * limitLevel;
                    } else {
                        limitSummary += "Can't be used unless you have at least " + limitLevel + ' Valor. ';
                        limitSt += 2 * limitLevel;
                    }
                } else if(limit.indexOf('clone') == 0) {
                    limitSummary += 'You must have an active Clone to use this Technique. ';
                    limitSt += 2;
                } else if(limit.indexOf('node sacrifice') == 0) {
                    limitSummary += 'Must originate from an Attack Node, and the node is destroyed. ';
                    limitSt += 8;
                } else if(limit.indexOf('refraction') == 0) {
                    limitSummary += 'Must pass through a Refraction Point to take effect. ';
                    limitSt += 2;
                } else if(limit.indexOf('time') == 0) {
                    let time = 5 - limitLevel;
                    limitSummary += 'Transformation ends after ' + time + ' turns. ';
                    limitSt += 5 * limitLevel;
                } else if(limit.indexOf('airborne') == 0) {
                    limitSummary += 'You must be Flying to use this Technique. ';
                    limitSt++;
                } else if(limit.indexOf('drop') == 0) {
                    limitSummary += 'You cease Flying after using this Technique. ';
                    limitSt += 4;
                } else if(limit.indexOf('revert') == 0) {
                    limitSummary += 'Your Transformation ends when you use this Technique. ';
                    limitSt += 10;
                } else if(limit.indexOf('ultimate cooldown') == 0) {
                    if(limitLevel == 1) {
                        limitSummary += "After using this Technique, you can't use it during the next scene. ";
                    } else {
                        limitSummary += "After using this Technique, you can't use it during the next " + limitLevel + ' scenes. ';
                    }
                    limitSt += 10 * limitLevel;
                } else if(limit.indexOf('ultimate health') == 0) {
                    damage = Math.ceil(hp / 5);
                    limitSummary += 'Costs ' + damage + ' Health. ';
                    limitSt += 20;
                } else if(limit.indexOf('ultimate valor') == 0) {
                    limitSummary += 'Costs ' + limitLevel + ' Valor. ';
                    limitSt += 10 * limitLevel;
                } else if(limit.indexOf('dark surrender') == 0) {
                    limitSummary += 'After using this Technique, you automatically surrender to your Malevolent Entity. ';
                    limitSt += 30;
                } else if(limit.indexOf('final') == 0) {
                    limitSummary += 'After using this Technique, your Health and Valor are both reduced to 0. ';
                    limitSt = 9999;
                } else if(limit.indexOf('sacrifice') == 0) {
                    limitSummary += "Costs " + 10 * limitLevel + " of an ally's Health. ";
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('fatigue') == 0) {
                    limitSummary += 'You become Fatigued after using this Technique. ';
                    limitSt += 15;
                } else if(limit.indexOf('weapon req') == 0) {
                    limitSummary += 'You must be holding your weapon to use this Technique. ';
                    limitSt += 3;
                } else if(limit.indexOf('weapon rel') == 0) {
                    limitSummary += "-10 damage if you aren't holding your weapon. ";
                    limitSt += 1;
                } else if(limit.indexOf('expendable') == 0) {
                    limitSummary += 'Consumes ammunition that must be purchased or found. ';
                    limitSt += limitLevel;
                } else if(limit.indexOf('sync') == 0) {
                    limitSummary += 'You must have at least ' + limitLevel + 'Synchronization with your Ego Weapon to use this Technique. ';
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('bloodseeker') == 0) {
                    limitSummary += 'Can only affect targets that are at Critical Health. ';
                    limitSt += 3;
                } else if(limit.indexOf('body strike') == 0) {
                    limitSummary += "Can only be used from your body. ";
                    limitSt += 1;
                } else if(limit.indexOf('elemental block') == 0) {
                    limitSummary += "Can't be used if you took damage from a specific element since your last turn. ";
                    limitSt += 2;
                } else if(limit.indexOf('exclusive') == 0) {
                    limitSummary += "Cancels out a specific other technique's effects when used. ";
                    limitSt += 1;
                } else if(limit.indexOf('head strike') == 0) {
                    limitSummary += "Can only be used from your head. ";
                    limitSt += 1;
                } else if(limit.indexOf('skill cancel') == 0) {
                    limitSummary += "When active, you lose a specific Skill. ";
                    limitSt += limitLevel;
                } else if(limit.indexOf('tail strike') == 0) {
                    limitSummary += "Can only be used from your tail. ";
                    limitSt += limitLevel;
                } else if(limit.indexOf('water') == 0) {
                    limitSummary += "Can only be used underwater. ";
                    limitSt += 3;
                } else if(limit.length > 0 &&
                          limit.indexOf('slow') == -1 &&
                          limit.indexOf('grant') == -1) {
                    warnings.push(`Unrecognized Limit '${limit}'.`);
                }
            });

            let cost = 0;
            if((core || techCore == 'custom') && techCore != 'mimic' && techCore != 'ultMimic') {
                if(techCore == 'custom') {
                    cost = techCustomCost;
                } else {
                    cost = core.cost + core.levelUp * (techCoreLevel + totalModLevel) - limitSt;
                }
                if(cost < 0) {
                    cost = 0;
                }

                summary += 'Costs ' + cost + ' Stamina. '
            }
            summary += limitSummary;

            // Determine Flaw SP
            let flawSpMax = 0;
            let flawSp = 0;
            if(hasFlaws) {
                switch(techCore) {
                    case 'weaken':
                    case 'domain':
                    case 'damage':
                    case 'ultDamage':
                        flawSpMax = techCoreLevel;
                        break;
                }
                const techFlawList = techInflictedFlaws.toLowerCase()
                    .split(',')
                    .map(s => {
                        if(s && s.length > 0) {
                            // Try to split out the flaw level
                            let split = s.split(' ');
                            let flawLevel = parseInt(split[split.length - 1]);
                            if(flawLevel != flawLevel) {
                                // NaN, so there's no level listed
                                return {
                                    name: s.trim(),
                                    level: 1
                                };
                            } else {
                                return {
                                    name: split.slice(0, split.length - 1).join(' ').trim(),
                                    level: flawLevel
                                };
                            }
                        } else {
                            return null;
                        }
                    })
                    .filter(s => s);

                for(const flaw of techFlawList) {
                    const flawData = flawLibrary.find(f => flaw.name.match(f.namePattern));
                    if(flawData) {
                        // Max flaw level
                        var flawMaxLevel = 1;
                        switch(flawData.speed) {
                            case 1:
                                flawMaxLevel = Math.ceil(level / 5);
                                break;
                            case 2:
                                flawMaxLevel = Math.ceil(level / 3);
                                break;
                            case 3:
                                flawMaxLevel = 100; // Custom Flaw
                        }
                        if(flaw.level > flawMaxLevel) {
                            warnings.push(`Max level for Flaw '${flaw.name}' is ${flawMaxLevel}.`);
                        }

                        flawSp += flawData.cost + flawData.levelUp * (flaw.level - 1);
                    } else {
                        warnings.push(`Unrecognized Flaw '${flaw.name}'.`);
                    }
                }
                if(flawSp > flawSpMax && flawSpMax > 0) {
                    warnings.push('Flaws exceed SP limit.');
                }
            }

            // Determine Skill SP
            let skillSpMax = 0;
            let skillSp = 0;
            if(hasSkills) {
                switch(techCore) {
                    case 'boost':
                    case 'ultTransform':
                    case 'domain':
                        skillSpMax = 2 * techCoreLevel;
                        break;
                }
                const techSkillList = techGrantedSkills.toLowerCase()
                    .split(',')
                    .map(s => {
                        if(s && s.length > 0) {
                            // Try to split out the flaw level
                            let split = s.split(' ');
                            let skillLevel = parseInt(split[split.length - 1]);
                            if(skillLevel != skillLevel) {
                                // NaN, so there's no level listed
                                return {
                                    name: s.trim(),
                                    level: 1
                                };
                            } else {
                                return {
                                    name: split.slice(0, split.length - 1).join(' ').trim(),
                                    level: skillLevel
                                };
                            }
                        } else {
                            return null;
                        }
                    })
                    .filter(s => s);

                for(const skill of techSkillList) {
                    const skillData = skillLibrary.find(s => skill.name.match(s.namePattern));
                    if(skillData) {
                        // Max skill level
                        var skillMaxLevel = 1;
                        switch(skillData.speed) {
                            case 1:
                                skillMaxLevel = Math.ceil(level / 5);
                                break;
                            case 2:
                                skillMaxLevel = Math.ceil(level / 3);
                                break;
                            case 3:
                                skillMaxLevel = 100; // Custom Flaw
                        }
                        if(skill.level > skillMaxLevel) {
                            warnings.push(`Max level for Skill '${skill.name}' is ${skillMaxLevel}.`);
                        }

                        skillSp += skillData.cost + skillData.levelUp * (skill.level - 1);
                    } else {
                        warnings.push(`Unrecognized Skill '${skill.name}''.`);
                    }
                }
                if(skillSp > skillSpMax && skillSpMax > 0) {
                    warnings.push('Skills exceed SP limit.');
                }
            }

            // Balance out Remaining Max SP for Domains
            if(techCore == 'domain') {
                flawSpMax -= Math.ceil(skillSp / 2);
                skillSpMax -= flawSp * 2;
            }

            let attrs = {};
            attrs['repeating_techs_' + techId + '_tech_summary'] = summary;
            attrs['repeating_techs_' + techId + '_tech_warnings'] = warnings.length > 0 ? `WARNING: ${warnings.join(' ')}` : ' ';
            attrs['repeating_techs_' + techId + '_tech_mod_level'] = totalModLevel;
            attrs['repeating_techs_' + techId + '_tech_level'] = techLevel;
            attrs['repeating_techs_' + techId + '_tech_limit_st'] = limitSt;
            attrs['repeating_techs_' + techId + '_tech_cost'] = cost;
            attrs['repeating_techs_' + techId + '_tech_flaw_sp'] = flawSp;
            attrs['repeating_techs_' + techId + '_tech_flaw_sp_max'] = flawSpMax;
            attrs['repeating_techs_' + techId + '_tech_skill_sp'] = skillSp;
            attrs['repeating_techs_' + techId + '_tech_skill_sp_max'] = skillSpMax;
            attrs[`repeating_techs_${techId}_tech_is_shield`] = techCore == 'shield'
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_is_mimic'] = techCore == 'mimic' || techCore == 'ultMimic'
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_has_flaws'] = hasFlaws
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_has_skills'] = hasSkills
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_can_dig_deep'] = (techValues.hasDigDeep && cost > 0)
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_can_overload_limits'] = techValues.hasOverloadLimits
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_can_empower'] = (techValues.hasEmpowerAttack &&
                (techCore == 'damage' || techCore == 'ultDamage' || techCore == 'mimic' || techCore == 'ultMimic'))
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_can_resolute_strike'] = (techValues.hasResoluteStrike &&
                (techCore == 'damage' || techCore == 'ultDamage' || techCore == 'mimic' ||
                techCore == 'ultMimic' || techCore == 'weaken'))
                ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_can_reroll'] = (isPersistent || isThrow) ? 'on' : 'off';
            attrs['repeating_techs_' + techId + '_tech_can_edit_cost'] = techCore == 'custom' ? 'on' : 'off';
            setAttrs(attrs, { silent: true });
        });
    }
    
    function calculateFlaw(flawId) {
        log('VALOR - Recalculating Flaw ID ' + flawId);

        let flawFieldNames = [];
        flawFieldNames.push(`repeating_flaws_${flawId}_flawname`);

        getAttrs(flawFieldNames, function(flawValues) {
            let flawName = flawValues[`repeating_flaws_${flawId}_flawname`];
            let flaw = flawLibrary.find(function(f) {
                return f.id == flawName;
            });
            
            let attrs = [];
            if(flaw.description) {
                attrs[`repeating_flaws_${flawId}_flawnotes`] = flaw.description;
            }
            
            setAttrs(attrs, { silent: true });
        });
    }
    
    function calculateSkill(skillId) {
        log('VALOR - Recalculating Skill ID ' + skillId);

        let skillFieldNames = [];
        skillFieldNames.push(`repeating_skills_${skillId}_skillname`);

        getAttrs(skillFieldNames, function(skillValues) {
            let skillName = skillValues[`repeating_skills_${skillId}_skillname`];
            let skill = skillLibrary.find(function(s) {
                return s.id == skillName;
            });
            
            let attrs = [];
            if(skill.description) {
                attrs[`repeating_skills_${skillId}_skillnotes`] = skill.description;
            }
            
            setAttrs(attrs, { silent: true });
        });
    }

    // Fix any null shield values    
    function calculateShields(skillId) {
        log('VALOR - Recalculating Shields');

        let fieldNames = ['pshield', 'eshield', 'vshield'];

        getAttrs(fieldNames, function(fieldValues) {
            var pshield = fieldValues['pshield'];
            var eshield = fieldValues['eshield'];
            var vshield = fieldValues['vshield'];
            
            if(!pshield) pshield = 0
            if(!eshield) eshield = 0
            if(!vshield) vshield = 0
            
            setAttrs({
                pshield: pshield,
                eshield: eshield,
                vshield: vshield,
            }, { silent: true });
        });
    }
    
    on("clicked:repeating_skills:useskill", function(eventInfo) {
        // Check the current value of the hidden attribute.
        const rowid = eventInfo.sourceAttribute.split('_')[2];
        getAttrs([`repeating_skills_${rowid}_skillname`, 
                  `repeating_skills_${rowid}_skilllevel`, 
                  `repeating_skills_${rowid}_skillnotes`,
                  'mus', 'dex', 'aur', 'int', 'res'], function(v) {
            let skillName = v[`repeating_skills_${rowid}_skillname`];
            let skill = skillLibrary.find(function(s) {
                return s.id == skillName;
            });
            let rollStat = null;
            let rollValue = 0;
            
            if(skill.rollStats) {
                // Pick a stat
                for(let i = 0; i < skill.rollStats.length; i++) {
                    const statValue = v[skill.rollStats[i]];
                    if(statValue > rollValue) {
                        rollStat = skill.rollStats[i];
                        rollValue = statValue;
                    }
                }
            }
            
            let rollStatName = null;
            switch(rollStat) {
                case 'mus':
                    rollStatName = 'Muscle';
                    break;
                case 'dex':
                    rollStatName = 'Dexterity';
                    break;
                case 'aur':
                    rollStatName = 'Aura';
                    break;
                case 'int':
                    rollStatName = 'Intuition';
                    break;
                case 'res':
                    rollStatName = 'Resolve';
                    break;
            }
            log(rollStat);
            log(rollStatName);
            let summary = v[`repeating_skills_${rowid}_skillnotes`];
            
            let command = rollStat ? `&{template:skill} {{name=${getDisplayName(skillName)}}} {{roll=[[${rollValue}+1d10]] ${rollStatName}}} {{summary=${summary}}}`
            : `&{template:skill} {{name=${getDisplayName(skillName)}}} {{summary=${summary}}}`;
            
            startRoll(command, function(result) {
                finishRoll(result.rollId);
            });
        });
    });
    
    on("clicked:repeating_flaws:useflaw", function(eventInfo) {
        // Check the current value of the hidden attribute.
        const rowid = eventInfo.sourceAttribute.split('_')[2];
        getAttrs([`repeating_flaws_${rowid}_flawname`, 
                  `repeating_flaws_${rowid}_flawlevel`, 
                  `repeating_flaws_${rowid}_flawnotes`,
                  'mus', 'dex', 'aur', 'int', 'res'], function(v) {
            let flawName = v[`repeating_flaws_${rowid}_flawname`];
            let flaw = flawLibrary.find(function(f) {
                return f.id == flawName;
            });
            
            let summary = v[`repeating_flaws_${rowid}_flawnotes`];
            
            let command = `&{template:flaw} {{name=${getDisplayName(flawName)}}} {{summary=${summary}}}`;
            
            startRoll(command, function(result) {
                finishRoll(result.rollId);
            });
        });
    });

    on('change:level change:str change:agi change:spr change:mnd change:gut', function() {
        calculateBaseAttributes();
    });

    on('change:level change:str change:agi change:spr change:mnd change:gut ' +
        'change:type change:repeating_skills remove:repeating_skills ' +
        'change:boostmus change:boostdex change:boostaur change:boostint change:boostres', function() {
        calculateAttack();
        calculateActiveAttributes();

    });

    on('change:stratk change:agiatk change:mndatk change:spratk', function() {
        getSectionIDs('repeating_techs', function(tidarray) {
            tidarray.forEach(function(techId) {
                calculateTech(techId);
            });
        });
    });

    on('change:level change:str change:gut change:type ' +
        'change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateHealth();
        calculateDefense();
    });

    on('change:level change:mnd change:spr change:type ' +
        'change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateStamina();
        calculateResistance();
    });

    on('change:agi change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateSpeed();
    });

    on('change:level change:type change:repeating_skills remove:repeating_skills', function() {
        calculateDamageIncrement();
    });

    on('change:dex change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateInitiative();
    });

    on('change:level change:type change:repeating_skills remove:repeating_skills ' +
        'change:repeating_flaws remove:repeating_flaws', function() {
        calculateFlawsAndSkills();
    });

    on('change:type change:repeating_skills remove:repeating_skills', function() {
        calculateBonuses();
    });

    on('change:level change:type change:repeating_skills remove:repeating_skills ' +
       'change:repeating_techs:tech_core_level change:repeating_techs:tech_mods change:repeating_techs:tech_core', function() {
        calculateTP();
    });

    on('change:repeating_techs:tech_name change:repeating_techs:tech_core_level ' +
       'change:repeating_techs:tech_core change:repeating_techs:tech_stat ' +
       'change:repeating_techs:tech_mods change:repeating_techs:tech_targets change:repeating_techs:tech_bonus ' +
       'change:repeating_techs:tech_limits change:repeating_techs:tech_description change:repeating_techs:tech_shield_type ' +
       'change:repeating_techs:tech_granted_skills change:repeating_techs:tech_inflicted_flaws ' +
       'change:repeating_techs:tech_custom_cost', function(eventInfo) {
        var techId = eventInfo.sourceAttribute.substring(16, 36);
        calculateTech(techId);
    });

    on('change:repeating_techs:tech_mods change:repeating_techs:tech_targets change:repeating_techs:tech_bonus '+
       'change:repeating_techs:tech_core change:repeating_techs:tech_limits change:repeating_techs:tech_name', function(eventInfo) {
        var techId = eventInfo.sourceAttribute.substring(16, 36);
        calculateTechCommand(techId);
    });

    on('change:repeating_skills remove:repeating_skills', function(eventInfo) {
        calculateBoostVisibility();
    });

    on('change:repeating_skills:skillname', function(eventInfo) {
        var skillId = eventInfo.sourceAttribute.substring(17, 37);
        calculateSkill(skillId);
    });

    on('change:repeating_flaws:flawname', function(eventInfo) {
        var flawId = eventInfo.sourceAttribute.substring(16, 36);
        calculateFlaw(flawId);
    });

    on('sheet:opened', function() {
        // Update attributes
        calculateBaseAttributes();
        calculateAttack();
        calculateActiveAttributes();
        calculateHealth();
        calculateDefense();
        calculateStamina();
        calculateResistance();
        calculateSpeed();
        calculateDamageIncrement();
        calculateInitiative();
        calculateFlawsAndSkills();
        calculateBonuses();
        calculateTP();
        calculateShields();

        // Update techs
        getSectionIDs('repeating_techs', function(tidarray) {
            tidarray.forEach(function(techId) {
                calculateTech(techId);
            });
        });
    });

</script>

<div class="sheet-container">
    <!-- Tabs -->
    <input type="radio" name="attr_tab" class="sheet-tab sheet-tab1" value="1" checked="checked"><span title="Attributes"></span>
    <input type="radio" name="attr_tab" class="sheet-tab sheet-tab2" value="2"><span title="Skills & Flaws"></span>
    <input type="radio" name="attr_tab" class="sheet-tab sheet-tab3" value="3"><span title="Techniques"></span>

    <div class="sheet-tab-content sheet-tab1">
        <!-- Sheet header -->
        <div class="attributes-header">
            <div class="attributes-header-label">
                <span class="label">Level:</span>
            </div>
            <div>
                <input class="attributes-header-input" type="number" name="attr_level" value="1">
            </div>
            <div class="attributes-header-label">
                <span class="label">Experience:</span>
            </div>
            <div>
                <input type="number" class="longer-number attributes-header-input" name="attr_exp" value="0">
            </div>
            <div class="attributes-header-label">
                <span class="label">Type:</span>
            </div>
            <div>
                <select name="attr_type" class="attributes-header-input">
                    <option value="flunky">Flunky</option>
                    <option value="soldier">Summon/Soldier</option>
                    <option value="swarm">Swarm</option>
                    <option value="elite" selected="selected">PC/Elite</option>
                    <option value="master">Master</option>
                </select>
            </div>
        </div>

        <!-- Attributes -->
        <div class="section-header">ATTRIBUTES</div>
        <div class="stats-container">
            <div class="stats">
                <div class="stats-column stats-orange">
                    <div class="label stats-column-header">BASE</div>
                    <div>Strength:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_str" value="5">
                    </div>
                    <div>Agility:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_agi" value="5">
                    </div>
                    <div>Spirit:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_spr" value="5">
                    </div>
                    <div>Mind:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_mnd" value="5">
                    </div>
                    <div>Guts:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_gut" value="5">
                    </div>
                </div>
                <div class="stats-column stats-green">
                    <div class="label stats-column-header">ACTIVE</div>
                    <div>Muscle:</div>
                    <div>
                        <span class="derived-value" name="attr_mus"></span>
                        <button type="roll" value='!roll-as @{character_id} "1d10+@{mus}+@{rollbonus}" "Muscle"' name="roll_mus"></button>
                        <input type="checkbox" class="conditional-check" name="attr_can_boost_mus">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_boostmus">
                            <span class="arrow">↑</span>
                        </div>
                    </div>
                    <div>Dexterity:</div>
                    <div>
                        <span class="derived-value" name="attr_dex"></span>
                        <button type="roll" value='!roll-as @{character_id} "1d10+@{dex}+@{rollbonus}" "Dexterity"' name="roll_dex"></button>
                        <input type="checkbox" class="conditional-check" name="attr_can_boost_dex">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_boostdex">
                            <span class="arrow">↑</span>
                        </div>
                    </div>
                    <div>Aura:</div>
                    <div>
                        <span class="derived-value" name="attr_aur"></span>
                        <button type="roll" value='!roll-as @{character_id} "1d10+@{aur}+@{rollbonus}" "Aura"' name="roll_aur"></button>
                        <input type="checkbox" class="conditional-check" name="attr_can_boost_aur">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_boostaur">
                            <span class="arrow">↑</span>
                        </div>
                    </div>
                    <div>Intuition:</div>
                    <div>
                        <span class="derived-value" name="attr_int"></span>
                        <button type="roll" value='!roll-as @{character_id} "1d10+@{int}+@{rollbonus}" "Intuition"' name="roll_int"></button>
                        <input type="checkbox" class="conditional-check" name="attr_can_boost_int">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_boostint">
                            <span class="arrow">↑</span>
                        </div>
                    </div>
                    <div>Resolve:</div>
                    <div>
                        <span class="derived-value" name="attr_res"></span>
                        <button type="roll" value='!roll-as @{character_id} "1d10+@{res}+@{rollbonus}" "Resolve"' name="roll_res"></button>
                        <input type="checkbox" class="conditional-check" name="attr_can_boost_res">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_boostres">
                            <span class="arrow">↑</span>
                        </div>
                    </div>
                </div>
                <div class="stats-column stats-orange">
                    <div class="label stats-column-header">ATTACK</div>
                    <div>Strength:</div>
                    <div class="derived-value">
                        <span name="attr_strAtk" />
                    </div>
                    <div>Agility:</div>
                    <div class="derived-value">
                        <span name="attr_agiAtk" />
                    </div>
                    <div>Spirit:</div>
                    <div class="derived-value">
                        <span name="attr_sprAtk" />
                    </div>
                    <div>Mind:</div>
                    <div class="derived-value">
                        <span name="attr_mndAtk" />
                    </div>
                    <div>
                        <!-- No guts attack -->
                    </div>
                </div>
                <div class="stats-column stats-green">
                    <div class="label stats-column-header">STATISTICS</div>
                    <div>Health:</div>
                    <div class="derived-value">
                        <span name="attr_hp_max" />
                    </div>
                    <div>Stamina:</div>
                    <div class="derived-value">
                        <span name="attr_st_max" />
                    </div>
                    <div>Defense:</div>
                    <div class="derived-value">
                        <span name="attr_defense" />
                    </div>
                    <div>Resistance:</div>
                    <div class="derived-value">
                        <span name="attr_resistance" />
                    </div>
                    <div>Move:</div>
                    <div class="derived-value">
                        <span name="attr_speed" />
                    </div>
                </div>
                <div class="stats-column stats-orange">
                    <div class="label stats-column-header">INCREMENTS</div>
                    <div>HP Increment:</div>
                    <div class="derived-value">
                        <span name="attr_hpInc" />
                    </div>
                    <div>ST Increment:</div>
                    <div class="derived-value">
                        <span name="attr_stInc" />
                    </div>
                    <div>Critical HP:</div>
                    <div class="derived-value">
                        <span name="attr_hpCrit" />
                    </div>
                    <div>Dmg Increment:</div>
                    <div class="derived-value">
                        <span name="attr_di" />
                    </div>
                    <div>Initiative:</div>
                    <div class="derived-value">
                        <span name="attr_init" ></span>
                        <button type="roll" value="[[1d10+@{init}+@{rollbonus} &{tracker} &{noerror}]] Initiative" name="roll_init"></button>
                    </div>
                </div>
            </div>
        </div>
        <div class="unspent-ap"><span name="attr_unspentAP"></span> AP UNSPENT</div>
        <div class="section-header">BONUSES</div>
        <div class="stats-container">
            <div class="stats">
                <div class="stats-wide-column stats-green stats-short">
                    <div>All Rolls:</div>
                    <div>
                        <input type="number" class="number-input-green" name="attr_rollbonus" value="0">
                    </div>
                    <div></div>
                    <div>Attack Rolls:</div>
                    <div>
                        <input type="number" class="number-input-green" name="attr_atkrollbonus" value="0">
                    </div>
                    <div>
                        <span name="attr_iatkrollbonusdisp"></span>
                    </div>
                    <div>Defense Rolls:</div>
                    <div>
                        <input type="number" class="number-input-green" name="attr_defrollbonus" value="0">
                    </div>
                    <div>
                        <span name="attr_idefrollbonusdisp"></span>
                    </div>
                </div>
                <div class="stats-column stats-orange stats-short">
                    <div>Phys. Attack:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_patkbonus" value="0">
                    </div>
                    <div>En. Attack:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_eatkbonus" value="0">
                    </div>
                </div>
                <div class="stats-column stats-green stats-short">
                    <div>Defense:</div>
                    <div>
                        <input type="number" class="number-input-green long-number" name="attr_defensebonus" value="0">
                    </div>
                    <div>Resistance:</div>
                    <div>
                        <input type="number" class="number-input-green long-number" name="attr_resistancebonus" value="0">
                    </div>
                </div>
                <div class="stats-column stats-orange stats-short">
                    <div>Physical Shield:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_pshield" value="0">
                    </div>
                    <div>Energy Shield:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_eshield" value="0">
                    </div>
                    <div>Versatile Shield:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_vshield" value="0">
                    </div>
                </div>
            </div>
        </div>
        <div class="section-header roll-defense">ROLL DEFENSE</div>
        <div class="defense-buttons">
            <button class="valor-button" type="roll" value='!roll-as @{character_id} "1d10+@{mus}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}" "Muscle Defense"' name="roll_mus_def">Muscle</button>
            <button class="valor-button" type="roll" value='!roll-as @{character_id} "1d10+@{dex}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}" "Dexterity Defense"' name="roll_dex_def">Dexterity</button>
            <button class="valor-button" type="roll" value='!roll-as @{character_id} "1d10+@{aur}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}" "Aura Defense"' name="roll_aur_def">Aura</button>
            <button class="valor-button" type="roll" value='!roll-as @{character_id} "1d10+@{int}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}" "Intuition Defense"' name="roll_int_def">Intuition</button>
            <button class="valor-button" type="roll" value='!roll-as @{character_id} "1d10+@{res}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}" "Resolve Defense"' name="roll_res_def">Resolve</button>
        </div>
    </div>

    <div class="sheet-tab-content sheet-tab2">
        <div class="flaws-header">FLAWS</div>
        <fieldset class="repeating_flaws">
            <div class="flaw">
                <div class="flaw-upper">
                    <select class="flaw-picker" name="attr_flawname" selected="customFlaw">
                        <option value="customFlaw">Custom Flaw</option>
                        <option value="aggravatedWounds">Aggravated Wounds (+2)</option>
                        <option value="berserker">Berserker (+5)</option>
                        <option value="compulsion">Compulsion (+4)</option>
                        <option value="despair">Despair (+4)</option>
                        <option value="energyVulnerability">Energy Vulnerability (+2/+1)</option>
                        <option value="feeble">Feeble (+3)</option>
                        <option value="fragile">Fragile (+3/+2)</option>
                        <option value="lackOfControl">Lack of Control (+2/+1)</option>
                        <option value="malevolentEntity">Malevolent Entity (+5)</option>
                        <option value="nonProficient">Non-Proficient (+1)</option>
                        <option value="oblivious">Oblivious (+3)</option>
                        <option value="slow">Slow (+2/+1)</option>
                        <option value="slowHealing">Slow Healing (+2)</option>
                        <option value="slowToAct">Slow to Act (+1)</option>
                        <option value="unthreatening">Unthreatening (+3)</option>
                        <option value="uncoordinated">Uncoordinated (+3)</option>
                        <option value="violent">Violent (+3)</option>
                        <option value="weakAura">Weak Aura (+3)</option>
                        <option value="weakDefender">Weak Defender (+2/+1)</option>
                        <option value="weakWilled">Weak Willed (+4/+3)</option>
                        <option disabled style="font-weight:bold" label="Optional Rules">
                            <option value="armorReliant">Armor Reliant (+2/+1)</option>
                            <option value="elementalVulnerability">Elemental Vulnerability (+2/+1)</option>
                            <option value="unprincipled">Unprincipled (+1)</option>
                            <option value="wardReliant">Ward Reliant (+2/+1)</option>
                        <option disabled style="font-weight:bold" label="NPC Only">
                            <option value="battleDamage">Battle Damage (+3)</option>
                        <option disabled style="font-weight:bold" label="Villains, Creatures and Foes (BETA)">
                            <option value="broadForm">Broad Form (+4)</option>
                            <option value="fearTheDarkness">Fear the Darkness (+3)</option>
                            <option value="immobile">Immobile (+7)</option>
                            <option value="insubstantial">Insubstantial (+3)</option>
                            <option value="situationalCompulsion">Situational Compulsion (+2)</option>
                            <option value="sunlightWeakness">Sunlight Weakness (+5)</option>
                            <option value="thresheld">Thresheld (+3)</option>
                            <option value="weakGuard">Weak Guard (+2)</option>
                            <option value="malevolentPossession">Malevolent Possession (+10)</option>
                    </select>
                    <span class="label">
                        Level <input class="flaw-level" type="number" name="attr_flawlevel" value="1" />
                    </span>
                    <span name="attr_warning"></span>
                    <button class="flaw-button" type="action" name="act_useflaw">Use</button>
                </div>
                <div><span class="label notes-label">Notes</span> <input class="notes" type="text" name="attr_flawnotes" /></div>
            </div>
            <div class="flaw-background"></div>
        </fieldset>

        <div class="skills-header">SKILLS</div>

        <fieldset class="repeating_skills">
            <div class="skill">
                <div class="skill-upper">
                    <select class="skill-picker" name="attr_skillname" selected="customSkill">
                        <option value="customSkill">Custom Skill</option>
                        <option disabled style="font-weight:bold" label="Season 1 Skills">
                            <option value="acceleration">Acceleration (5)</option>
                            <option value="analysis">Analysis (5)</option>
                            <option value="asset">Asset (3)</option>
                            <option value="attackNode">Attack Node (5/2)</option>
                            <option value="balancedFighter">Balanced Fighter (8)</option>
                            <option value="blazingMight">Blazing Might (6/3)</option>
                            <option value="bounceBack">Bounce Back (6)</option>
                            <option value="bravado">Bravado (6/6)</option>
                            <option value="burningPassion">Burning Passion (5)</option>
                            <option value="challengeTechnique">Challenge Technique (3)</option>
                            <option value="combinationAttack">Combination Attack (6)</option>
                            <option value="companion">Companion (6/4)</option>
                            <option value="counterattack">Counterattack (6)</option>
                            <option value="cover">Cover (6/2)</option>
                            <option value="crisis">Crisis (4/2)</option>
                            <option value="curseResistance">Curse Resistance (6)</option>
                            <option value="dangerSense">Danger Sense (3)</option>
                            <option value="darkHealing">Dark Healing (5)</option>
                            <option value="darksight">Darksight (4)</option>
                            <option value="desperation">Desperation (5)</option>
                            <option value="digDeep">Dig Deep (5)</option>
                            <option value="dirtyTrick">Dirty Trick (5)</option>
                            <option value="discreetAura">Discreet Aura (3)</option>
                            <option value="discretion">Discretion (2)</option>
                            <option value="duel">Duel (2)</option>
                            <option value="effectTransfer">Effect Transfer (4/3)</option>
                            <option value="empowerAttack">Empower Attack (6/3)</option>
                            <option value="energyAttacker">Energy Attacker (6/3)</option>
                            <option value="fastCompanion">Fast Companion (2/1)</option>
                            <option value="fastHealing">Fast Healing (4)</option>
                            <option value="favorableInsight">Favorable Insight (3)</option>
                            <option value="feint">Feint (6)</option>
                            <option value="fightingSpirit">Fighting Spirit (6/3)</option>
                            <option value="hardenedDefense">Hardened Defense (6/3)</option>
                            <option value="hardenedResistance">Hardened Resistance (6/3)</option>
                            <option value="hiddenCompanion">Hidden Companion (4/2)</option>
                            <option value="ignoreEffect">Ignore Effect (5)</option>
                            <option value="improvedDamageIncrement">Improved Damage Inc. (4/2)</option>
                            <option value="improvedSwimming">Improved Swimming (4)</option>
                            <option value="increasedSize">Increased Size (2/1)</option>
                            <option value="inspire">Inspire (5)</option>
                            <option value="interruptAttack">Interrupt Attack (3/2)</option>
                            <option value="intimidate">Intimidate (5/3)</option>
                            <option value="ironDefense">Iron Defense (4/2)</option>
                            <option value="jump">Jump (4)</option>
                            <option value="mount">Mount (3/1)</option>
                            <option value="nimbleMovement">Nimble Movement (4)</option>
                            <option value="nullify">Nullify (5/3)</option>
                            <option value="overloadLimits">Overload Limits (6)</option>
                            <option value="passiveHealing">Passive Healing (4)</option> (6)
                            <option value="physicalAttacker">Physical Attacker (6/3)</option>
                            <option value="proficiency">Proficiency (2)</option>
                            <option value="protector">Protector (5)</option>
                            <option value="provoke">Provoke (4/2)</option>
                            <option value="quickToAct">Quick to Act (3)</option>
                            <option value="recharge">Recharge (5/3)</option>
                            <option value="recklessAttack">Reckless Attack (5/3)</option>
                            <option value="recovery">Recovery (3)</option>
                            <option value="resistant">Resistant (4/2)</option>
                            <option value="resoluteAura">Resolute Aura (5)</option>
                            <option value="resoluteStrike">Resolute Strike (5)</option>
                            <option value="revenge">Revenge (5)</option>
                            <option value="rollingRecovery">Rolling Recovery (4)</option>
                            <option value="senseMalice">Sense Malice (2)</option>
                            <option value="sizeUp">Size Up (3/1)</option>
                            <option value="spiritSight">Spirit Sight (5)</option>
                            <option value="sprinter">Sprinter (4/2)</option>
                            <option value="strengthOfWill">Strength of Will (5)</option>
                            <option value="teamTactics">Team Tactics (5)</option>
                            <option value="tireless">Tireless (5/2)</option>
                            <option value="tough">Tough (6/3)</option>
                            <option value="toss">Toss (5/2)</option>
                            <option value="underhanded">Underhanded (5)</option>
                            <option value="unmovable">Unmovable (4/2)</option>
                            <option value="versatileFighter">Versatile Fighter (6/3)</option>
                        <option disabled style="font-weight:bold" label="Season 2 Skills">
                            <option value="abundantCreation">Abundant Creation (5)</option>
                            <option value="afterimage">Afterimage (4)</option>
                            <option value="allyMount">Ally Mount (3/1)</option>
                            <option value="areaShield">Area Shield (4)</option>
                            <option value="battleAnalysis">Battle Analysis (6)</option>
                            <option value="clash">Clash (3)</option>
                            <option value="clone">Clone (6/3)</option>
                            <option value="cloneTactics">Clone Tactics (5)</option>
                            <option value="combatToss">Combat Toss (4)</option>
                            <option value="companionZoneOfControl">Companion ZOC (4/4)</option>
                            <option value="damageFeedback">Damage Feedback (5)</option>
                            <option value="daredevil">Daredevil (4)</option>
                            <option value="divingEscape">Diving Escape (5/2)</option>
                            <option value="effectCapture">Effect Capture (4)</option>
                            <option value="extendedRevival">Extended Revival (4)</option>
                            <option value="favorableSuccess">Favorable Success (4)</option>
                            <option value="finalAttack">Final Attack (6)</option>
                            <option value="flankAttack">Flank Attack (4)</option>
                            <option value="healthTransference">Health Transference (4)</option>
                            <option value="lineDeflect">Line Deflect (5)</option>v
                            <option value="mobileCover">Mobile Cover (5)</option>
                            <option value="mobileDodge">Mobile Dodge (4)</option>
                            <option value="opportunisticDodge">Opportunistic Dodge (6)</option>
                            <option value="phasing">Phasing (5)</option>
                            <option value="portal">Portal (6/3)</option>
                            <option value="protectAlly">Protect Ally (2)</option>
                            <option value="protectMaster">Protect Master (3)</option>
                            <option value="pushAway">Push Away (4/2)</option>
                            <option value="rangedInterrupt">Ranged Interrupt (4)</option>
                            <option value="rangedRevival">Ranged Revival (3)</option>
                            <option value="refractionPoint">Refraction Point (4/2)</option>
                            <option value="risingAttack">Rising Attack (6)</option>
                            <option value="seal">Seal (6/3)</option>
                            <option value="shadowMeld">Shadow Meld (6)</option>
                            <option value="shrugOff">Shrug Off (6)</option>
                            <option value="splitMove">Split Move (6)</option>
                            <option value="staminaTransference">Stamina Transference (6)</option>
                            <option value="swiftStep">Swift Step (5/2)</option>
                            <option value="tossingCompanion">Tossing Companion (3/1)</option>
                            <option value="transposition">Transposition (4)</option>
                            <option value="trustingCompanion">Trusting Companion (4)</option>
                            <option value="wallWalk">Wall Walk (4)</option>
                            <option value="waterAdaptation">Water Adaptation (6)</option>
                            <option value="waterWalk">Water Walk (4)</option>
                            <option value="xRayVision">X-Ray Vision (4)</option>
                        <option disabled style="font-weight:bold" label="Season 3 Skills">
                            <option value="attackNodeNetwork">Attack Node Network (4)</option>
                            <option value="companionSense">Companion Sense (2)</option>
                            <option value="defensiveClash">Defensive Clash (4)</option>
                            <option value="deflectingShield">Deflecting Shield (4)</option>
                            <option value="exploitWeakness">Exploit Weakness (6)</option>
                            <option value="flunkyDomination">Flunky Domination (5)</option>
                            <option value="fly">Fly (6/2)</option>
                            <option value="flyingCompanion">Flying Companion (3/3)</option>
                            <option value="instantMonut">Instant Mount (3)</option>
                            <option value="prepared">Prepared (6)</option>
                            <option value="reactiveCompanion">Reactive Companion (4)</option>
                            <option value="refractionChain">Refraction Chain (6)</option>
                            <option value="swiftJump">Swift Jump (3)</option>
                            <option value="unshakeable">Unshakeable (6)</option>
                            <option value="unstoppable">Unstoppable (6)</option>
                        <option disabled style="font-weight:bold" label="Season 4 Skills">
                            <option value="breakValorLimit">Break Valor Limit (6)</option>
                            <option value="expandedReach">Expanded Reach (8)</option>
                            <option value="extendedRange">Extended Range (4)</option>
                            <option value="extraAction">Extra Action (12)</option>
                            <option value="freeFlight">Free Flight (3)</option>
                            <option value="freeSwiftStep">Free Swift Step (5)</option>
                            <option value="regeneration">Regeneration (6/4)</option>
                            <option value="staminaRecovery">Stamina Recovery (4/2)</option>
                            <option value="teleportation">Teleportation (6)</option>
                            <option value="unyieldingDetermination">Unyielding Determination (6)</option>
                            <option value="violentAura">Violent Aura (4)</option>
                        <option disabled style="font-weight:bold" label="Season 1 (Optional Rules)">
                            <option value="elementalResistance">Elemental Resistance (4/2)</option>
                            <option value="elementalAttunement">Elemental Attunement (3)</option>
                            <option value="illusoryDisguise">Illusory Disguise (3)</option>
                            <option value="illusoryTerrain">Illusory Terrain (4/2)</option>
                            <option value="pierceIllusion">Pierce Illusion (4)</option>
                            <option value="principled">Principled (2)</option>>
                        <option disabled style="font-weight:bold" label="Season 2 (Optional Rules)">
                            <option value="illusoryAssailant">Illusory Assailant (6/3)</option>
                        <option disabled style="font-weight:bold" label="Season 1 (NPC Only)">
                            <option value="invisibility">Invisibility (8)</option>
                        <option disabled style="font-weight:bold" label="Season 2 (NPC Only)">
                            <option value="revive">Revive (8/3)</option>
                        <option disabled style="font-weight:bold" label="Season 4 (NPC Only)">
                            <option value="limitlessPower">Valiant (12)</option>
                        <option disabled style="font-weight:bold" label="Villains, Creatures and Foes (BETA)">
                        <option disabled style="font-weight:bold" label="Traits">
                            <option value="aquatic">Aquatic (1)</option>
                            <option value="construct">Construct (8)</option>
                            <option value="elemental">Elemental (5)</option>
                            <option value="undead">Undead (8)</option>
                        <option disabled style="font-weight:bold" label="Season 1">
                            <option value="diminuitive">Diminuitive (6)</option>
                            <option value="healer">Healer (4/2)</option>
                            <option value="increasedLength">Increased Length (1/1)</option>
                            <option value="morale">Morale (6)</option>
                            <option value="hardenedResolve">Hardened Resolve (6)</option>
                            <option value="amphibious">Amphibious (3)</option>
                            <option value="toweringPresence">Towering Presence (6)</option>
                            <option value="humanshape">Humanshape (3)</option>
                            <option value="limitedFlight">Limited Flight (4/2)</option>
                            <option value="pressingSwarm">Pressing Swarm (6)</option>
                            <option value="skillCopy">Skill Copy (?)</option>
                            <option value="swiftStance">Swift Stance (3/1)</option>
                            <option value="increasedCompanionSize">Increased Companion Size (1/1)</option>
                        <option disabled style="font-weight:bold" label="Season 2">
                            <option value="largeHead">Large Head (1)</option>
                            <option value="limitedRegeneration">Limited Regeneration (4/3)</option>
                            <option value="longTail">Long Tail (1)</option>
                            <option value="trample">Trample (8)</option>
                            <option value="ultimateAttack">Ultimate Attack (12)</option>
                            <option value="victorAtAnyCost">Victor At Any Cost (8)</option>
                        <option disabled style="font-weight:bold" label="Season 3">
                            <option value="alteredDurability">Altered Durability (3)</option>
                            <option value="burrow">Burrow (6)</option>
                            <option value="durableFlunky">Durable Flunky (6/3)</option>
                            <option value="resurrectingFlunky">Resurrecting Flunky (8)</option>
                            <option value="standTall">Stand Tall (6)</option>
                            <option value="terrainAdaptation">Terrain Adaptation (6)</option>
                        <option disabled style="font-weight:bold" label="Season 4">
                            <option value="destructiveBurrow">Destructive Burrow (6)</option>
                            <option value="freeBurrow">Free Burrow (3)</option>
                            <option value="landAdaptation">Land Adaptation (4)</option>
                            <option value="shapeshifter">Shapeshifter (12)</option>
                            <option value="unscrupulous">Unscrupulous (6)</option>
                    </select>
                    <span class="label">Level</span> <input class="skill-level" type="number" name="attr_skilllevel" value="1" />
                    <span name="attr_warning"></span>
                    <button class="skill-button" type="action" name="act_useskill">Use</button>
                </div>
                <span class="label">Notes</span> <input class="notes" type="text" name="attr_skillnotes" />
            </div>
        </fieldset>

        <div class="unspent-sp"><span name="attr_unspentSP"></span> SP UNSPENT</div>
    </div>

    <div class="sheet-tab-content sheet-tab3">
        <div class="techs-header">TECHNIQUES</div>

        <fieldset class="repeating_techs">
            <div class="tech-name">
                <input type="text" class = "tech-name" name="attr_tech_name" value="New Technique" />
            </div>
            <div class="tech">
                <div class="spacer"></div>
                <div class="tech-level">
                    <div class="tech-header">
                        <span class="label">Tech Level</span>
                        <span class="derived-value" name="attr_tech_level">
                    </div>
                </div>
                <div class="tech-button">
                    <button class="valor-button" type='roll' name='attr_tech_command'> Use Technique</button>
                    <span class="label">Targets</span>
                    <select name="attr_tech_targets" class="number-select tech-field tech-small-input">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9">9</option>
                        <option value="10">10</option>
                        <option value="11">11</option>
                        <option value="12">12</option>
                        <option value="13">13</option>
                        <option value="14">14</option>
                        <option value="15">15</option>
                        <option value="16">16</option>
                        <option value="17">17</option>
                        <option value="18">18</option>
                        <option value="19">19</option>
                        <option value="20">20</option>
                    </select>
                    <span class="label">Bonus</span> <input class="tech-field tech-small-input" type='number' value='0' name='attr_tech_bonus'>
                    <div>
                        <input type="checkbox" class="conditional-check" name="attr_tech_can_dig_deep">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_tech_digDeep">
                            <span class="label">Use Dig Deep</span>
                        </div>
                    </div>
                    <div>
                        <input type="checkbox" class="conditional-check" name="attr_tech_can_overload_limits">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_tech_overloadLimits">
                            <span class="label">Use Overload Limits</span>
                        </div>
                    </div>
                    <div>
                        <input type="checkbox" class="conditional-check" name="attr_tech_can_empower">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_tech_empowerAttack">
                            <span class="label">Use Empower Attack</span>
                        </div>
                    </div>
                    <div>
                        <input type="checkbox" class="conditional-check" name="attr_tech_can_resolute_strike">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_tech_resoluteStrike">
                            <span class="label">Use Resolute Strike</span>
                        </div>
                    </div>
                    <div>
                        <input type="checkbox" class="conditional-check" name="attr_tech_can_reroll">
                        <div class="conditional-block">
                            <input type="checkbox" name="attr_tech_reroll">
                            <span class="label">Reroll</span>
                        </div>
                    </div>
                </div>
                <div>
                    <span class="label">Core:</span>
                </div>
                <div class="tech-core">
                    <select class="tech-field" name="attr_tech_core">
                        <option value="barrier">Barrier Core</option>
                        <option value="boost">Boost Core</option>
                        <option value="damage" selected="selected">Damage Core</option>
                        <option value="healing">Healing Core</option>
                        <option value="shield">Shield Core</option>
                        <option value="mimic">Mimic Core</option>
                        <option value="summoning">Summoning Core</option>
                        <option value="weaken">Weaken Core</option>
                        <option disabled style="font-weight:bold" label="Ultimate Cores">
                            <option value="domain">Personal Domain</option>
                            <option value="ultDamage">Ultimate Attack</option>
                            <option value="ultMimic">Ultimate Mimic</option>
                            <option value="ultTransform">Transformation</option>
                        <option value="custom">Custom Core</option>
                    </select>
                </div>
                <div class="tech-core-level">
                    <span class="label">Core Power:</span>
                    <input class="tech-field tech-small-input" type="number" name="attr_tech_core_level" value="1" />
                </div>
                <div class="tech-summary">
                    <div><span name="attr_tech_description"></span></div>
                    <div><span name="attr_tech_summary"></span></div>
                    <div><span name="attr_tech_warnings"></span></div>
                </div>
                <div>
                    <span class="label">Attribute:</span>
                </div>
                <div class="tech-attribute">
                    <select class="tech-field" name="attr_tech_stat">
                        <option value="none" selected="selected">None</option>
                        <option value="str">Strength</option>
                        <option value="agi">Agility</option>
                        <option value="spr">Spirit</option>
                        <option value="mnd">Mind</option>
                        <option value="gut">Guts</option>
                    </select>
                </div>
                <div class="tech-cost">
                    <input type="checkbox" class="conditional-check" name="attr_tech_can_edit_cost">
                    <div class="conditional-block">
                        <span class="label">ST Cost:</span>
                        <input class="tech-field tech-small-input" type="number" name="attr_tech_custom_cost" value="0" />
                    </div>
                    <div class="conditional-block-inverse">
                        <span class="label">ST Cost</span>
                        <span class="derived-value" name="attr_tech_cost"></span>
                    </div>
                </div>
                <div>
                    <input type="checkbox" class="conditional-check" name="attr_tech_is_shield">
                    <div class="conditional-block">
                        <span class="label">Shield Type:</span>
                    </div>
                </div>
                <div>
                    <input type="checkbox" class="conditional-check" name="attr_tech_is_shield">
                    <div class="tech-shield-type conditional-block">
                        <select class="tech-field" name="attr_tech_shield_type" title="@{repeating_techs_#_tech_shield_type}" >
                            <option value="physical" selected="selected">Physical</option>
                            <option value="energy">Energy</option>
                            <option value="versatile">Versatile</option>
                        </select>
                    </div>
                </div>
                <div class="tech-description">
                    <div class="label">Description</div>
                    <div>
                        <textarea class="smallertext tech-field" name="attr_tech_description"></textarea>
                    </div>
                </div>
                <div class="tech-optional-fields">
                    <div class="tech-conditional-field">
                        <input type="checkbox" class="conditional-check" name="attr_tech_has_skills">
                        <div class="tech-block conditional-block">
                            <span class="label">Skills:</span>
                            <input type="text" class="tech-field" name="attr_tech_granted_skills" />
                            (<span class="sp_label" name="attr_tech_skill_sp"></span>/<span class="sp_label" name="attr_tech_skill_sp_max"></span>)
                        </div>
                    </div>
                    <div class="tech-conditional-field">
                        <input type="checkbox" class="conditional-check" name="attr_tech_has_flaws">
                        <div class="tech-block conditional-block">
                            <span class="label">Flaws:</span>
                            <input type="text" class="tech-field" name="attr_tech_inflicted_flaws" />
                            (<span class="sp_label" name="attr_tech_flaw_sp"></span>/<span class="sp_label" name="attr_tech_flaw_sp_max"></span>)
                        </div>
                    </div>
                    <div class="tech-conditional-field">
                        <input type="checkbox" class="conditional-check" name="attr_tech_is_mimic">
                        <div class="tech-block conditional-block">
                            <span class="label">Mimicked Tech:</span>
                            <input class="tech-field" type="text" name="attr_tech_mimic_target" />
                        </div>
                    </div>
                </div>
                <div class="tech-modifiers">
                    <div class="label">Modifiers (one per line)</div>
                    <div>
                        <textarea class="smalltext tech-field" name="attr_tech_mods" rows="3" cols="40"></textarea>
                    </div>
                    <div>
                        Total Mod Levels <span name="attr_tech_mod_level" class="derived-value"></span>
                    </div>
                </div>
                <div class="tech-limits">
                    <div class="label">Limits (one per line)</div>
                    <div>
                        <textarea class="smalltext tech-field" name="attr_tech_limits" rows="3" cols="40"></textarea>
                    </div>
                    <div>
                        Total Cost Reduction <span name="attr_tech_limit_st" class="derived-value"></span>
                    </div>
                </div>
            </div>
        </fieldset>
        <div class="unspent-tp"><span name="attr_unspentTP"></span> TP UNSPENT</div>
    </div>

</div>

<br />

<div>
    <input type="checkbox" class="conditional-check" name="attr_is_duplicate">
    <div class="tech-block conditional-block">
        <button type='roll' value='!d-finalize @{character_id}' name='roll_resolve'>Finalize Level-up</button>
    </div>
    <div class="tech-block conditional-block-inverse">
        <button type='roll' value='!duplicate @{character_id}' name='roll_duplicate'>Create Level-up Sheet</button>
    </div>
</div>

<rolltemplate class="sheet-rolltemplate-valor">
    <div class="outer">
        <div class="header">
            {{name}}
        </div>
        {{#roll}}
        <br />
        <div class="roll">
            {{roll}}
        </div>
        {{/roll}}
        {{#summary}}
        <div>
            {{summary}}
        </div>
        {{/summary}}
    </div>
</rolltemplate>

<rolltemplate class="sheet-rolltemplate-skill">
    <div class="outer">
        <div class="header">
            {{name}}
        </div>
        {{#roll}}
        <br />
        <div class="roll">
            {{roll}}
        </div>
        {{/roll}}
        {{#summary}}
        <div>
            {{summary}}
        </div>
        {{/summary}}
    </div>
</rolltemplate>

<rolltemplate class="sheet-rolltemplate-flaw">
    <div class="outer">
        <div class="header">
            {{name}}
        </div>
        {{#roll}}
        <br />
        <div class="roll">
            {{roll}}
        </div>
        {{/roll}}
        {{#summary}}
        <div>
            {{summary}}
        </div>
        {{/summary}}
    </div>
</rolltemplate>
